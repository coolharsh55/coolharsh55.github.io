<h1>Abstract</h1>
<p>The advent of smartphones as a computing device has resulted in a shift in focus towards the design and development of smartphone applications or apps, that allow the user to complete a wide range of tasks on their devices. The users depend on apps installed on their smartphones to access services such as emails, photos, music, browsing, messaging and telephony. However, the overall user experience is disjointed as users are required to use multiple apps to complete a task where each app requires the user to enter the same information as the apps cannot share the data contextually.</p>
<p>This thesis investigates how smartphone apps can perform contextual data sharing with an emphasis on practical integration into the existing platforms and app models. The identification of information and its associated context is necessary to create context definitions that allow different apps to identify the context of the shared data. An approach to model the Context Definitions using computer science concepts such as object-oriented data structures provides flexibility. A context datastore is defined to store and share contextual information between apps, which creates an independence between apps for acquiring information and provides compatibility with the existing security models on various platforms. The model allows apps to retrieve contextual data in a simple and efficient manner without interacting directly with the other apps.</p>
<p>This thesis explains the author’s hypothesis of creating contextual services in apps based on the availability of contextual information on a smartphone device. An implementation of the model proving the hypothesis is presented on Android using native tools and technologies available on the platform. The demonstration aims to show the viability of the model through use cases, evaluations and performance metrics.</p>
<p>Finally, the author provides recommendation for developers in adoption of the model, and the efforts required to integrate the implementation into existing platforms and apps. Further research avenues are identified that define the future of research in this area.</p>
<hr/>
<h1 id="introduction">Introduction</h1>
<h2 id="introduction-1">Introduction</h2>
<p><em>“Focus on the user and all else will follow.”</em></p>
<p>– <em>Google’s 9 Principles of Innovation</em></p>
<p>Smartphones are the most popular computing device <span class="citation" data-cites="gartner"><a href="#ref-gartner" role="doc-biblioref">[1]</a></span> due to their ability to offer features such as web browsing, navigation and media consumption along with communication. The most popular smartphone operating systems in use today are Android and iOS <span class="citation" data-cites="comScore_mobilelens"><a href="#ref-comScore_mobilelens" role="doc-biblioref">[2]</a></span>, which grew in popularity within a short span of time.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The features in a smartphone are exploited by apps, which are third-party native applications that provide functionality and utility on the smartphone. Within a short time, the number of smartphone applications have increased tremendously<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and has led to the formation of an ecosystem comparable to software on a traditional personal computer. The term <em>app</em> is a shortening of the term <em>application software</em>, which became popular in 2009 when technology columnist David Pogue said that newer smartphones could be nicknamed “<em>app phones</em>” <span class="citation" data-cites="app_phones"><a href="#ref-app_phones" role="doc-biblioref">[6]</a></span>, and when app was listed as “Word of the Year” by the American Dialect Society <span class="citation" data-cites="app_wordoftheyear"><a href="#ref-app_wordoftheyear" role="doc-biblioref">[7]</a></span> in 2010. In a study done in 2012, <em>comScore</em> reported that more users used apps for a service than using its website <span class="citation" data-cites="comScore_appsusage"><a href="#ref-comScore_appsusage" role="doc-biblioref">[8]</a></span>. The popularity of apps has lead to various studies, with research showing that usage of mobile apps strongly correlates with user context and depends on user’s location and time of the day <span class="citation" data-cites="appusage_context"><a href="#ref-appusage_context" role="doc-biblioref">[9]</a></span>. Thus, smartphone apps have an important relation to the user’s context, as they perform a large number of tasks on a device that users keep with them at all times.</p>
<p>Different kinds of applications have the potential to utilize different kinds of contextual information, but are restricted when it comes to sharing this information with the other applications. Smartphone applications use <em>sandboxing</em> <span class="citation" data-cites="Sandboxing"><a href="#ref-Sandboxing" role="doc-biblioref">[10]</a></span>, a security model that prevents an application from accessing or changing another app’s data. A consequence of this approach is the restrictions in using an app’s data to create contextual services on the device. Since apps cannot easily share information with each other, the user is required to input the same information multiple times in different apps used for a task where various apps handle the different steps related to the task. This restrictive data sharing between the apps limits the availability of contextual information on the smartphone as data generated or entered within an app is not available outside the app. The information locked within the apps can be utilized for generating contextual use cases and capabilities that can help users complete their tasks in a faster and simpler way. The Contextual Data Sharing Model described in this research alleviates this problem by storing related contextual information from different apps, which can be accessed and utilized to develop contextual services. This increases the usability of the apps and prevents duplication of effort and information while making it easier for users to perform the related steps belonging to a task.</p>
<h3 id="sec:existing_problems_and_limitations">Existing Problems and Limitations</h3>
<p>Applications that utilize context generally focus on using a limited set of contextual information. The various previous approaches <span class="citation" data-cites="ContextSysClassify"><a href="#ref-ContextSysClassify" role="doc-biblioref">[11]</a></span> related to using contextual information on a smartphone have focused on using contexts such as time, location and device sensor information to model contextual services. The efforts related to providing high-level contexts to apps on smartphones have not seen the necessary advances in research required for adoption in spite of the rising popularity of smartphones.</p>
<h4 id="sub:using_the_cloud">Apps and the Cloud</h4>
<p>The interactions between apps and the cloud has made it possible for apps to provide more information and features. This has led to the creation of Smart apps <span class="citation" data-cites="SMARTAPPS"><a href="#ref-SMARTAPPS" role="doc-biblioref">[12]</a></span> and Intelligent Personal Assistants that can answer questions, make recommendations, and perform actions by delegating requests to a set of web services. These applications provide services based on the availability of contextual information related to the user. For example, Google Now <span class="citation" data-cites="Google:Now"><a href="#ref-Google:Now" role="doc-biblioref">[13]</a></span> shows information about upcoming events it acquires by parsing emails from the users’ Gmail address <span class="citation" data-cites="GmailCards"><a href="#ref-GmailCards" role="doc-biblioref">[14]</a></span>. It is possible for Google Now to access and parse users’ email since both the services exist within the same Google ecosystem. For other apps that are outside this ecosystem, the contextual information is not available without requiring some explicit steps from users to make such information available. This limited availability of information restricts the development of contextual services to only those apps that have access to a large dataset of information about the user, which is then analyzed and modeled into contextual information.</p>
<h4 id="sub:data_sharing_in_smartphone_applications">Limitations in Data Sharing</h4>
<p>Mobile operating systems such as Android (v5.0.2) and iOS (v8.1.2) provide various ways for apps to share data, but lack a comprehensive framework to share contextual information across apps. Apps that wish to share contextual information must conform to a standard format for the data being exchanged that is understood uniformly by all involved apps. This places a burden on app developers to explicitly program interactions between different apps in order to facilitate the sharing of information though a mutually agreed API. The applications and their developers are thus unable to utilize all the contextual information available on a device, and are limited in the extent to which they can provide context-aware services.</p>
<p>The ranking of top apps is dominated by apps from developers Facebook, Google, Apple, Yahoo, Amazon and eBay. These six companies account for 9 of the top 10 most used apps, 16 of the top 25, and 24 of the top 50 <span class="citation" data-cites="mostpopularapps"><a href="#ref-mostpopularapps" role="doc-biblioref">[15]</a></span>. This shows the preference of users to use apps within the same ecosystem which provides them with contextual features across apps developed by the same developer. This leads to other app developers prioritizing the integration of services and APIs from such popular apps the user is most likely to install. For example, the calendar app Sunrise <span class="citation" data-cites="CalendarSunrise"><a href="#ref-CalendarSunrise" role="doc-biblioref">[16]</a></span> integrates birthdays and reminders from Facebook and Google+ along with a few others.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Information from only these services are synced and shown within Sunrise. Other comparable calendar apps that do not integrate these services can be deemed as being less attractive by the users based on the absence of features. This reduces the users’ choice, and increases the pressure on app developers to integrate more services and APIs in their apps. The lack of a framework that supports the implicit sharing of information restricts developers to focus on a few services that are popular. This creates a necessity for apps to expose APIs to facilitate integration and cohesion which may help adoption by users. This leads to developers depending on APIs which are sometimes unsupported for interacting with an application that does not explicitly support integration. X-Callback-Url <span class="citation" data-cites="xcallback"><a href="#ref-xcallback" role="doc-biblioref">[17]</a></span> is one such effort that provides documentation for services that can be integrated in other apps, but does not provide any way to structure or identify the data being shared.</p>
<h4 id="sub:example_use_case">Example Use Case: Movie Ticket Booking</h4>
<p>In most common use cases, all the related information is available on a smartphone, but is distributed across different applications which are unable to share the information with each other. This creates difficulties in generation and consumption of contexts in a smartphone, and forces the user to interact with different apps in order to complete a task covering a single context. This situation can be described using the movie ticket booking use case shown in Fig. <a href="#fig:movie_use_case" data-reference-type="ref" data-reference="fig:movie_use_case">[fig:movie_use_case]</a>, where the various steps taken by an user from booking the movie ticket to attending the movie show require the use of separate apps that do not share related information even though acting in the same context. The various steps followed by the user and the duplication of information and effort can be seen in the following steps:</p>
<figure>
    <img src="img/002-movie_use_case.png" />
    <figcaption>Figure 1.1: A use case highlighting the use of multiple apps used in the context of a movie ticket booking</figcaption>
</figure>
<ol>
<li><p><strong>Movie Booking App</strong>: The user enters or selects the movie’s title, theater location, the show’s date and time. The app generates the ticket and seat information which is stored within the app or sent to the user as an email or a text message.</p></li>
<li><p><strong>Calendar App</strong>: The user creates an entry for the movie in the calendar. The title, date/time and location fields of this entry are duplicated by the user from the movie’s title, show time and theater location. The user also has the option of adding a list of contacts who will be attending the movie with him/her.</p></li>
<li><p><strong>Messaging App</strong>: The user forwards or copies the information containing the movie information sent by the movie booking app in a text message. The list of recipients is most likely related to the contacts added in the calendar. Here the user duplicates the movie information when entering the message contents, and the list of contacts as the recipients.</p></li>
<li><p><strong>Maps App</strong>: The user uses the maps app to access route and navigational information when going to the theater, which requires entering the theater’s address to set it as the destination. This information is duplicated along with the user being required to remember the location or look it up in a previously stored place such as the movie booking app or within messages. Some calendar apps offer navigational features within the app <span class="citation" data-cites="CalendarFantastical CalendarSunrise"><a href="#ref-CalendarSunrise" role="doc-biblioref">[16]</a>, <a href="#ref-CalendarFantastical" role="doc-biblioref">[18]</a></span>, which require the user to open the calendar app in order to use this feature. Calendar apps that provide a navigational link in the notification only do so when the notification is displayed to the user. To access the navigational features at other times, the user needs to open the maps app or the calendar app containing a map.</p></li>
<li><p><strong>Accessing seat information</strong>: At the theater, the user may require the seat numbers and ticket information to enter the theater or to print the tickets. This information can be accessed from the movie booking app, or in the copy stored as a message or an email, which involves several steps from opening the app to finding the relevant information. To make this information easily accessible at the theater, the user can use an app that offers reminders based on the location. The contents of such a reminder would include the required movie information, and the trigger would be the theater’s location. Setting up the reminder requires effort on the part of the user and further duplication of the movie information.</p></li>
</ol>
<p>Table <a href="#tab:info_entered" data-reference-type="ref" data-reference="tab:info_entered">[tab:info_entered]</a> shows the information entered by the user in various apps, with the fields that were entered multiple times being counted as being duplicated information. The label <em>APP</em> denotes information generated by the app, <em>USER</em> denotes information entered by the user for the first time, and <em>DUP</em> denotes duplicated information. It can be clearly seen from the table that a large amount of information is duplicated, which increases the effort required to complete the task as the user enters the same information in different apps. The overall user experience becomes disjointed as each app acts in an individual capacity based on the information available to it. This example shows the need for related information (in this case the movie’s information) to be shared between apps to facilitate contextual services that will offer users a unified experience resulting from the availability of information across apps pertaining to the same context.</p>
<table id="tab:info_entered">
    <tr>
        <td>App used</td>
        <td>Movie Title</td>
        <td>Show Date/Time</td>
        <td>Attending Contacts</td>
        <td>Theater Location</td>
        <td>Ticket Info</td>
    </tr>
    <tr>
        <td>Booking</td>
        <td>USER</td>
        <td>USER</td>
        <td>NA</td>
        <td>USER</td>
        <td>APP</td>
    </tr>
    <tr>
        <td>Calendar</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>USER</td>
        <td>DUP</td>
        <td>DUP</td>
    </tr>
    <tr>
        <td>Messages</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
    </tr>
    <tr>
        <td>Maps</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
    </tr>
    <tr>
        <td>Reminder</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
        <td>DUP</td>
    </tr>
</table>
<h3 id="sec:statement_of_the_problem">Statement of the Problem</h3>
<p>The problems and limitations described in the previous section can be mitigated with a Contextual Data Sharing Model that pervasively manages and mediates access to contexts on a smartphone. The model would allow for simple and intuitive access to contextual information stored across applications. The design and implementation of such a model is motivated by three key challenges in the area of context-awareness:</p>
<ol>
<li><p>Identifying the contextual information;</p></li>
<li><p>An effective method for accessing this information;</p></li>
<li><p>Defining a contextual data store for storing the information.</p></li>
</ol>
<p>The model allows apps to access contextual information without requiring explicit interaction and identifications of other apps, which leads to creation of features and services that help create a better user experience.</p>
<h3 id="sec:purpose_of_the_study">Purpose of Research</h3>
<p>The purpose of this research is to design a Contextual Data Sharing Model and its various components in a manner that can be easily integrated and used by existing applications. The implementation of the model is a proof-of-concept demonstration that shows the viability of the model, and its impact on the user experience.</p>
<h3 id="sec:significant_of_the_study">Significance of Research</h3>
<p>The Contextual Data Sharing Model provides applications access to contextual information which can be easily stored and shared, and allows app developers to integrate contextual use cases in a simpler and more intuitive way. The contextual services can be designed relevant to the user’s tasks without directly collaborating or sharing information with other apps. This allows a better user experience on the device, and leads to better features that allow recognizing and handling tasks the user is most likely to perform.</p>
<h3 id="sec:primary_research_questions">Primary Research Questions</h3>
<p>The primary research questions that motivated the design and implementation of the Contextual Data Sharing Model are-</p>
<ol>
<li><p>How can contextual information be structured in a uniform way?</p></li>
<li><p>How can contextual information be stored in a context datastore?</p></li>
<li><p>How can apps share contextual information through the Contextual Data Sharing Model without direct interaction or awareness of other apps?</p></li>
<li><p>Can an implementation of the model be created using a platform’s native technologies?</p></li>
<li><p>What is the viability and performance of such an implementation?</p></li>
<li><p>Is the implementation stable and efficient to be used practically?</p></li>
<li><p>What are the impacts of the implementation on user experience?</p></li>
</ol>
<p>The answers to these questions form the basis and motivation of this research.</p>
<h3 id="sec:hypothesis">Hypothesis</h3>
<h5 id="primary---availability-of-contextual-information-leads-to-a-better-user-experience">Primary - availability of contextual information leads to a better user experience</h5>
<p>The primary hypothesis of this research is that the availability of contextual information for smartphone applications can lead to better features and an intuitive user experience. The hypothesis can be tested by comparing the user experience of use cases with and without the use of the Contextual Data Sharing Model. The conclusions reached through testing verify the impact of contextual information on user experience and app development.</p>
<h5 id="secondary---use-of-native-technologies-makes-it-easier-to-develop-and-manage-contextual-information">Secondary - use of native technologies makes it easier to develop and manage contextual information</h5>
<p>The secondary hypothesis of this research is that using native technologies in implementation allows for easier development and management of contextual information. The hypothesis states that using native technologies to implement the Contextual Data Sharing Model makes it easy to manage the information on a device and facilitates the sharing of information across applications without the need for developing or utilizing complex technologies that a platform does not natively support. It also makes it easy for developers to integrate contextual information and services into applications, which allows them to focus on developing contextual services rather than acquiring information.</p>
<h3 id="sec:research_design">Research Design</h3>
<p>Different parts of the work follow different research designs. The representation of contexts is largely evolved from previous approaches and research in this area. The storage of contextual information is more considerate about the restrictions of a smartphone device, and is based on managing efficiency with performance. The implementation of the model is experimental in its approach as it attempts to combine the various components of the Contextual Data Sharing Model with the existing smartphone platform environment.</p>
<h3 id="sec:assumptions_limitations_and_scope_">Assumptions, Limitations and Scope (Delimitations)</h3>
<h4 id="sub:assumptions">Assumptions</h4>
<ol>
<li><p>All apps involved or specified will use the Contextual Data Sharing Model in the specified manner.</p></li>
<li><p>The app that generates or identifies contextual information will correctly add it to the context data store.</p></li>
<li><p>Apps are aware of the contextual nature of the information acquired or entered by the user.</p></li>
</ol>
<h4 id="sub:limitations">Limitations</h4>
<p>The research is cognizant of the following limitations-</p>
<ol>
<li><p>Apps need to adapt and use the Contextual Data Sharing Model in order for it to work across the device.</p></li>
<li><p>Apps can only provide contextual services based on the availability of information in the context datastore. When such information is absent, the app cannot provide contextual services.</p></li>
<li><p>The onus is on apps generating or identifying contextual information to insert it in the context datastore. If apps fail to add information to the datastore, the apps may not be able to provide contextual services.</p></li>
<li><p>The implementation of the model varies in some aspects depending on changes in platforms, devices and use cases.</p></li>
</ol>
<h4 id="sub:scope">Scope</h4>
<p>The scope of the research is to make contextual information accessible to apps within the smartphone ecosystem through a framework that is designed with a bias towards popular smartphone operating systems like Android and iOS. The implementation of such a framework is based on the demonstration of the model on an unmodified version of Android with the aim to demonstrate the feasibility, impact and performance of the model. The implementation is termed as <em>working, but experimental</em>, and needs further efforts for testing and handling more use cases.</p>
<p><span id="sub:delimitations" label="sub:delimitations">[sub:delimitations]</span></p>
<h3 id="sec:introduction_summary">Summary</h3>
<p>The Contextual Data Sharing Model enables apps to access contextual information without explicitly interacting with each other. This allows apps to create contextual services based on the availability of data which leads to the creation of better features and services that make the user experience richer and more engaging. The described movie ticket booking use case requires the user to enter the same information multiple times in different apps which duplicates information and increases effort. By using the Contextual Data Sharing Model, the amount of effort and information entered by the user can be significantly reduced as apps share the information based on the context of the task implied by the user. The apps identify the nature of shared information and provide related contextual services accordingly. This allows features such as the calendar showing the movie event without requiring the user to enter any data. The maps app can provide routes to the theater based on the show time of the movie with a reminder at the theater showing the ticket and seat information. The use of contexts as defined in the model does not require dependence on the apps that generate or identify the information, which allows various apps to act independently.</p>
<h3 id="thesis-outline">Thesis Outline</h3>
<p>This thesis is structured as follows:</p>
<p><strong>Part II - Literature Review and Technical Background</strong></p>
<p><strong>Chapter 2 - Context-aware Computing</strong>. Chapter two looks at the previous approaches that identify and use contextual information. The emergence of context-aware computing and its use in mobile devices is also examined.</p>
<p><strong>Chapter 3 - Data Sharing in Smartphone Applications</strong>. Chapter three discusses the various data sharing methods available to smartphone applications on Android and iOS.</p>
<p><strong>Part III - The Contextual Data Sharing Model</strong></p>
<p><strong>Chapter 4 - Context Definition</strong>. Chapter four discusses the structuring of contextual information using Context Definitions. The chapter introduces the use of Context Definitions to store contextual information in a structured schema to provide a uniform representation across apps. The design and structure required for an implementation of the Context Definitions is also discussed.</p>
<p><strong>Chapter 5 - Context Database</strong>. Chapter five introduces the Context Database used for storing contextual information. The design and structure of the Context Database along with its performance is also discussed.</p>
<p><strong>Chapter 6 - Contextual Data Sharing Model</strong>. Chapter six introduces the Contextual Data Sharing Model and its components. The chapter discusses the various components and their responsibilities along with how contextual data sharing is achieved through the model. A demonstration of how apps would use the model is also discussed through a use case.</p>
<p><strong>Part IV - Contextual Data Sharing in Android</strong></p>
<p><strong>Chapter 7 - Implementation</strong>. Chapter seven discusses the implementation of the Contextual Data Sharing Model on Android. The software and design approaches used in the implementation of the various components are also discussed. A demonstration of an use case with the apps using the Contextual Data Sharing Model on Android is also provided.</p>
<p><strong>Chapter 8 - Performance Evaluation</strong>. Chapter eight discusses the various performance and user effort metrics of the implementation of the Contextual Data Sharing Model on Android. The focus of the evaluation is on the user effort, the operation times of the queries and the CPU utilization of the apps.</p>
<p><strong>Part V - This Research and its Future Potential</strong></p>
<p><strong>Chapter 9 - Conclusion</strong>. Chapter nine presents an overview of the research, listing the advantages and validation of using the Contextual Data Sharing Model. Conclusions are drawn regarding the performance and user experience of the model along with its outcomes.</p>
<p><strong>Chapter 10 - Future Work</strong>. Chapter ten discusses the various approaches that can extend and improve upon this research. The chapter provides various approaches to extend the model to other devices and platforms such as iOS, wearable computing, and smart devices. An idea of an ecosystem of devices where users are provided services based upon their contextual information is also discussed.</p>
<h1 id="literature-review-and-technical-background">Literature Review and Technical Background</h1>
<h2 id="context-aware-computing">Context-aware Computing</h2>
<p><em>“If I have seen further it is by standing on the shoulders of giants.”</em></p>
<p>– <em>Isaac Newton</em></p>
<h3 id="sub:defining_context">Defining Context</h3>
<p>The word <em>context</em>, derived from Latin <em>con</em> meaning with or together, and <em>textere</em> meaning to weave, denotes context as a profile and an active process dealing with the way humans weave their experiences within their whole environment to give it meaning. The word ‘context’ also denotes the study of human ‘text’ and the idea of ‘situated cognition.’ The idea that context changes the interpretation of text goes back many thousand years.</p>
<p>In computer science, context awareness refers to the idea that computers can both sense, and react based on their environment. Context aware devices try to react based on rules and intelligent stimulus based on the user’s current situation. The term context awareness in ubiquitous computing was first defined in 1994 as: <em>“software that adapts according to its location of use, the collection of nearby people and objects, as well as changes to those objects over time."</em> <span class="citation" data-cites="Contextawarecomputing Schilit:1994:DAM:2329093.2330030"><a href="#ref-Contextawarecomputing" role="doc-biblioref">[19]</a>, <a href="#ref-Schilit:1994:DAM:2329093.2330030" role="doc-biblioref">[20]</a></span> Previous research in this area has resulted in several adaptive and personalized applications based on the notion of user profile and context <span class="citation" data-cites="contextmodelssurvey"><a href="#ref-contextmodelssurvey" role="doc-biblioref">[21]</a></span>. Some of them that have motivated and influenced this research are summarized in this section.</p>
<p>The definition of context as given by Dey <span class="citation" data-cites="ContextDef"><a href="#ref-ContextDef" role="doc-biblioref">[22]</a></span> is: “<em>Context is any information that can be used to characterize the situation of an entity. An entity is a person, place, or object that is considered relevant to the interaction between a user and an application, including the user and applications themselves.</em>” A definition of context-aware systems is also provided as: “<em>A system is context-aware if it uses context to provide relevant information and/or services to the user, where relevancy depends on the user’s task.</em>” Their paper discusses the different ways context can be used by context-aware applications. Three categories of features that a context-aware application can support are given as: presentation of information and services to the user, automatic execution of a service for a user, and tagging of context to information to support later retrieval.</p>
<p>Zimmermann et al. <span class="citation" data-cites="ContextOpDef"><a href="#ref-ContextOpDef" role="doc-biblioref">[23]</a></span> extend the context definitions with the idea of defining the task itself as part of the context since it characterizes the situation of the user. This central role of task in context is shared by Crowley et al. <span class="citation" data-cites="TaskCentral1"><a href="#ref-TaskCentral1" role="doc-biblioref">[24]</a></span> and Kofod-Petersen et al. <span class="citation" data-cites="TaskCentral2"><a href="#ref-TaskCentral2" role="doc-biblioref">[25]</a></span>, who assume that the user’s actions are generally identified by a set of tasks (actions) and are goal driven. Henricksen <span class="citation" data-cites="TaskCentral3"><a href="#ref-TaskCentral3" role="doc-biblioref">[26]</a></span> gives more importance to task in her definition of context, which is: “<em>The context of a task is the set of circumstances surrounding it that are potentially of relevance to its completion</em>.” Dey et al. <span class="citation" data-cites="ContextDef2"><a href="#ref-ContextDef2" role="doc-biblioref">[27]</a></span> extend their definition of context with the statement <em>“Context is typically the location, identity and state of people, groups and computational and physical objects.”</em> Abowd et al. <span class="citation" data-cites="ContextDef3"><a href="#ref-ContextDef3" role="doc-biblioref">[28]</a></span> discuss how context can be considered a part of the process along with the state in which the users are involved. Chen <span class="citation" data-cites="TaskCentral4"><a href="#ref-TaskCentral4" role="doc-biblioref">[29]</a></span> uses location as a context-providing parameter with activities and tasks taking place in a location.</p>
<h3 id="sub:context_in_mobile_devices">Context in Mobile Devices</h3>
<p>Battestini et al. <span class="citation" data-cites="MobileContext1"><a href="#ref-MobileContext1" role="doc-biblioref">[30]</a></span> discuss how mobile phones can be used to create intelligent applications that are able to understand user needs through context and have the ability to adapt and provide recommendations. They extend the idea of a statistical approach to context recognition by defining contexts as clusters in the data <span class="citation" data-cites="Battestini_analysisand"><a href="#ref-Battestini_analysisand" role="doc-biblioref">[31]</a></span>, which can be used to recognize clusters unambiguously associated with high-level contexts or situations. Two examples of context-aware applications given are the Context Watcher and the Family Maps, built using the MobiLife<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> architecture and which utilizes various sources of information to predict and infer the users’ needs. The authors express the need for a user-centric privacy and trust framework that will allow flexible information exchange while controlling the access to user data.</p>
<p>Malik and Mahmud <span class="citation" data-cites="malikmahmud"><a href="#ref-malikmahmud" role="doc-biblioref">[32]</a></span> identified the following challenges for middleware that addresses context awareness:</p>
<ol>
<li><p>Context acquisition to collect the items of the context: context-aware middleware can centralize context data from various sources and sensors.</p></li>
<li><p>Context representation that provides an efficient structure for retrieving context. The authors mention the various approaches for representing context. <span class="citation" data-cites="Strang04acontext"><a href="#ref-Strang04acontext" role="doc-biblioref">[33]</a></span></p></li>
<li><p>Context storage which stores correctly represented context in a structured and persistent manner.</p></li>
<li><p>Context interpretation based on different strategies and fields of research such as machine learning or complex event processing to enable context-awareness.</p></li>
<li><p>Context adaptation to use the context after interpretation in context-aware scenarios.</p></li>
</ol>
<p>Yau et al. <span class="citation" data-cites="RCSM"><a href="#ref-RCSM" role="doc-biblioref">[34]</a></span> describe RCSM, a system that creates ad hoc communication between devices to facilitate information exchange. They present two categories of middleware in pervasive computing based on interaction between devices or entities. Their implementation uses various sensors to detect light, noise, etc. in a classroom to trigger communication activity between students and instructor. The system uses a state-trigger based scenario where context states trigger activities.</p>
<p>Klein et al. <span class="citation" data-cites="access_schemes"><a href="#ref-access_schemes" role="doc-biblioref">[35]</a></span> describe a context management architecture based on the producer-consumer role model and designed to acquire, manage, and distribute context information and to control the context quality. The architecture consists of a Context Provider where context information originates from and is provided to other entities of the architecture; a Context Broker that acts as a middleman to perform lookups and resolutions; and Context Consumers that use context data as an input for providing functionality. The authors note the the dependence of the ”quality” of context information on connectivity and its impact on delay, accuracy, relevance, and confidence, which requires a Context Quality Enabler incorporated into the architecture to control the provision of context information.</p>
<p>Korpipaa et al. <span class="citation" data-cites="ContextAwareFramework"><a href="#ref-ContextAwareFramework" role="doc-biblioref">[36]</a></span> describe a framework for the development of context-aware mobile applications that manages raw contextual information gained from multiple sources and enables higher-level context abstractions. The framework contains a central node that provides context information to clients through direct querying, subscribing to context change notification services or higher-level composite contexts managed by the context manager. Each context is described using six properties where each context expression contains at least one type and value, which together form a verbal description of the context.</p>
<p>Alidin and Crestani <span class="citation" data-cites="contextjit"><a href="#ref-contextjit" role="doc-biblioref">[37]</a></span> describe the “just-in-time” approach where relevant information is retrieved without the user requesting it. This reduces the user’s effort, time and interaction and presents the relevant information to the user in the right time and place. The authors note how smartphones can react and adapt to the context to minimize user interaction and use context as information triggers to pro-actively present information to the user. This is also known as Just-In-Time Information Access system <span class="citation" data-cites="Leake99selectingtask-relevant"><a href="#ref-Leake99selectingtask-relevant" role="doc-biblioref">[38]</a></span>. In this system, if the information is no longer relevant to the user interaction, then it is not considered to be a part of the context. The authors describe how some researchers incorporate too many dimensions of context which make the context models too complex to be implemented in smartphones. But if there are fewer dimensions of context, it can lead to context models being unable to understand the whole context. In their approach, they define 10 dimensions of context including time, location, sound and user profile. The context model has structured levels of context where sensor data is at the bottom level. Context dimensions or low-level context are characterized by interpreting multiple sensor data. High-level contexts are generated from multiple context dimensions and describe the user’s current context. A user scenario depicts the situations encountered by the user and is made up of one or more high-level context. The system works by monitoring context, predicting user information needs in any given context and pro-actively providing the user with relevant information with the aim to reduce user interaction. The system infers user information need in context based on the user’s current context and an information need analyzer. If this information is not available, the system predicts user information need by acquiring context from other closely similar users, or by utilizing the user’s location, preference, and context.</p>
<p>Falcarin et al. present an architectural framework for context-aware services called <em>Context Data Management</em> <span class="citation" data-cites="contextdatamanagement"><a href="#ref-contextdatamanagement" role="doc-biblioref">[39]</a></span> that provides interoperability and domain independence for third-party context-aware applications. The authors describe a high-level framework that provides a set of defined roles for abstract components that offer APIs. The framework provides context data management, context analysis and integration of context in mobile devices, with a focus on sensor data. The main component called Context Broker manages communications with the other components, while Context Providers store information that can be queried by Context Broker or Context Consumers. Context Sources provide data to the Context Broker through asynchronous communication and are typically located on mobile devices. The Context Broker organizes data into different Context Scopes, which are subscribed by Context Consumers in a publisher-subscriber model. A Context Cache stores recent context data, which is moved to a Context History database upon expiry.</p>
<p>Context Directory <span class="citation" data-cites="contextdirectory"><a href="#ref-contextdirectory" role="doc-biblioref">[40]</a></span> is a framework that helps mobile applications to achieve context-awareness through context models, interpretation methods and adaptation possibilities. The framework consists of context clients, which communicate with the sensors on the mobile devices to collect context attributes for creating context representations. It uses a key/value model for simplicity and to allow multiple context clients to collect context attributes on different devices which can be merged into context directories. The communication between directories and clients is handled by the context directory protocol. A context-aware API allows development of context-aware applications for specific mobile platforms and can be used to build a context-aware application based on the interface. Developers can directly interact with context clients for more control over the sensitivity of contexts. The context is interpreted using a variety of algorithms based on usability of context-aware scenarios. A demonstration of the framework is shown through a context-aware application for Android, where the context-aware API was modeled to be similar to the Android API. Context commands, which describe the adaptation of user interfaces and the behavior of executed commands are developed based on the context. Contextual information is implemented by a context-matching module that sorts information based on time and relevancy. The authors note the possibility and complexity of using automatic contextual reconfiguration using Dalvik’s reflection mechanism.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> The application model and possible actions need to be registered in the context directory for executing context-triggered actions.</p>
<p>Most definitions and implementations of context-aware systems focus on using aspects such as time, location and sensor information to model contextual systems. While these can be used to cover a large variety of common use cases in mobile devices, there is more information associated with other contexts on mobile devices that needs to be recognized and used.</p>
<h3 id="sub:cloud_middleware_and_framework">Context Frameworks utilizing the Cloud</h3>
<p>Many contextual models use a cloud-based approach, where the cloud is utilized to offer services not possible on a mobile device and to share information between multiple devices. Offloading work to the cloud enables services not previously possible on mobile devices as described in <span class="citation" data-cites="MobileCloud1 MobileCloud2 MobileCloud4 MobileCloud5 MobileCloud3"><a href="#ref-MobileCloud1" role="doc-biblioref">[41]</a>–<a href="#ref-MobileCloud3" role="doc-biblioref">[45]</a></span>.</p>
<p>One such approach related to this research is <em>COSMOS</em> <span class="citation" data-cites="COSMOS"><a href="#ref-COSMOS" role="doc-biblioref">[46]</a></span>, which describes a cloud-based PaaS (Platform as a Service) system that provides infrastructure for mobile apps to share data. The authors emphasize the incentive for mobile apps to share information with one another on a large scale through a service based in the cloud and hosting the mobile apps’ datasets. They provide an implementation model that hosts app data in the cloud and provides seamless experience by sharing that data with multiple apps. The COSMOS PaaS system contains Sharing Middleware (SMILE) that mediates sharing between mobile tenants and the COSMOS data store. The implementation focuses on sharing data across apps hosted in COSMOS and targets user services towards contextual information gathered from various datasets. An example provided is that of a user going to a conference, where his conference date and location is used to book airline tickets and the hotel room. The COSMOS datasets provide all the information required without the user specifying these requirements. For all services to work, the app must be hosted in COSMOS and must use its architecture.</p>
<p>The Cloud Personal Assistant <span class="citation" data-cites="CPA"><a href="#ref-CPA" role="doc-biblioref">[47]</a></span> is a cloud service that manages the access of mobile clients to cloud services. It provides service discovery and invocation, and stores the results and history for delivery to the mobile client. The assistant receives a set of tasks to execute, and returns the results when the mobile client needs them. There are three tiers called the user tier, the task tier and the service tier. The framework provides independence from connectivity as the results are stored in the cloud and returned when the mobile client requests them.</p>
<h3 id="sub:classification_of_context_aware_systems_and_services">Classification of Context-aware Systems and Services</h3>
<p>A surveys and comparison of context-aware systems and models is presented in <span class="citation" data-cites="contextmodelssurvey"><a href="#ref-contextmodelssurvey" role="doc-biblioref">[21]</a></span>. Baldauf and Dustdar <span class="citation" data-cites="Baldauf04asurvey"><a href="#ref-Baldauf04asurvey" role="doc-biblioref">[48]</a></span> survey various context-aware middleware and frameworks and present a comparative analysis focusing on the context services. They conclude their analysis with two points, the first being that appliances should vanish into the background to make the user and his tasks the central focus rather than computing devices and technical issues. The second is that context-aware systems are able to adapt their operations to the current context without explicit user intervention and thus aim at increasing usability and effectiveness by taking environmental context into account.</p>
<p>According to Strang et al. <span class="citation" data-cites="Strang04acontext"><a href="#ref-Strang04acontext" role="doc-biblioref">[33]</a></span> there are six ways of modeling and representing context data amongst existing works:</p>
<ol>
<li><p>Key-value pairs, which are primitive and cannot handle complex context information, but easy to integrate;</p></li>
<li><p>Graphical models, which describe the structure of context, but do not separate the data layer from code layer;</p></li>
<li><p>Object-oriented models, which encapsulate the context in objects and can provide special interfaces, but are not efficient at large-scales;</p></li>
<li><p>Logic-based models, which define context as a set of facts and evaluative expressions which can be used to derive new facts, but are complex and restrictive;</p></li>
<li><p>Ontology-based models, which use formally specify concepts and interrelations of the human language, and can grow to a large size;</p></li>
<li><p>XML models, which are hierarchal data structures made up of XML tags with attributes and contents and offer dynamicity of information, but are require separate services to interact with the data.</p></li>
</ol>
<p>Schilit et al. <span class="citation" data-cites="Contextawarecomputing"><a href="#ref-Contextawarecomputing" role="doc-biblioref">[19]</a></span> defined four categories of context-aware applications that overlap with the categories defined by Pascoe <span class="citation" data-cites="Pascoe:1998:AGC:857199.858020"><a href="#ref-Pascoe:1998:AGC:857199.858020" role="doc-biblioref">[49]</a></span>, who defined the following five categories of context-aware applications:</p>
<ol>
<li><p>Contextual information or proximate selection or contextual sensing, which describes the supply of context-aware content by an application. This is a form of matching or rating of information by context.</p></li>
<li><p>Contextual commands, which are the category of applications that change their presentation or execution flow based on the context.</p></li>
<li><p>Automatic contextual reconfiguration, which exchanges parts of the software based on context.</p></li>
<li><p>Context-triggered actions that enable executing applications and operations without inputs based on the context. Similar mechanisms are used by online shopping systems.</p></li>
<li><p>Contextual augmentation, which enhance the perspective on the environment by adding additional information to the reality.</p></li>
</ol>
<p>Chihani and Bertin <span class="citation" data-cites="ContextSysClassify"><a href="#ref-ContextSysClassify" role="doc-biblioref">[11]</a></span> give a new approach for classifying context-aware communication systems, where adaptation is performed based on how context is used. They identify services as Instant or Deferred and On Device or On Cloud based on their implementation instead of their functionalities. They also note that the most used context sources are physical information such as location and time, environmental information such as weather, personal information such as health, mood and social information such as relationships and applicative information such as emails. They discuss how high-level knowledge can be derived from raw contextual information to give a better understanding of the user.</p>
<h3 id="sub:representing_context">Context Representations</h3>
<p>There have been various ways proposed to represent context. Most researchers represent context using formats tied to their particular approach. Some of the commonly used and popular formats for representing contexts are Resource Description Framework (RDF) <span class="citation" data-cites="RDF"><a href="#ref-RDF" role="doc-biblioref">[50]</a></span> and OWL <span class="citation" data-cites="OWL"><a href="#ref-OWL" role="doc-biblioref">[51]</a></span>.</p>
<h4 id="sub:rdf">Resource Description Framework (RDF)</h4>
<p>RDF is a data model that uses statements about resources in the form of subject-predicate-object expressions known as <em>triples</em>. The subject denotes the resource, the predicate denotes the traits or aspects of the resource and expresses a relationship between the subject and the object. For example, for representing the English language statement <em>‘New York has the postal abbreviation NY’</em> in RDF, <em>‘New York’</em> would be the subject, <em>‘has the postal abbreviation’</em> would be the predicate, and <em>‘NY’</em> would be the object. To be encoded as a triple, the subject and predicate need to be expressed as URI resources, and the object can be a resource or a literal element. The example expressed in Listing <a href="#lst:rdf" data-reference-type="ref" data-reference="lst:rdf">[lst:rdf]</a> is in N-Triples form, where <em>‘urn:x-states:New%20York’</em> is the URI for a resource that denotes the US state New York, <em>‘http://purl.org/dc/terms/alternative’</em> is the URI for this predicate<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, and <em>‘NY’</em> is a literal string.</p>
<figure id="lst:rdf">
    <pre><code>&lt;urn:x-states:New%20York&gt;
&lt;http://purl.org/dc/terms/alternative&gt;
&quot;NY&quot;</code></pre>
    <figcaption>Schema for <em>Event</em> Context</figcaption>
</figure>
<h4 id="sub:web_ontology_language">Web Ontology Language (OWL)</h4>
<p>The Web Ontology Language (OWL) is a family of knowledge representation languages or ontology languages for authoring ontologies or knowledge bases. The languages are characterized by formal semantics and RDF/XML-based serializations for the Semantic Web. The data described by an ontology in the OWL family is interpreted as a set of <em>individuals</em> and a set of <em>property assertions</em> which relate these individuals to each other. An ontology consists of a set of axioms which place constraints on sets of individuals (called <em>classes</em>) and the types of relationships permitted between them. These axioms provide semantics by allowing systems to infer additional information based on the data explicitly provided.</p>
<p>Languages in the OWL family are capable of creating classes, properties, defining instances and its operations. An instance is an object and corresponds to a description of an individual logic. A class is a collection of objects and corresponds to a description of a logic concept. A class may contain individuals and any number instances of the class. An instance may belong to none, one or more classes. A class may be a subclass of another, inheriting characteristics from its parent superclass. All classes are subclasses of <em>owl:Thing</em>, the root class. All classes are subclassed by <em>owl:Nothing</em>, the empty class. No instances are members of <em>owl:Nothing</em>. Modelers use <em>owl:Thing</em> and <em>owl:Nothing</em> to assert facts about all or no instances. A property is a directed binary relation that specifies class characteristics. It corresponds to a description logic role. They are attributes of instances and sometimes act as data values or link to other instances. Properties may possess logical capabilities such as being transitive, symmetric, inverse and functional. Properties may also have domains and ranges.</p>
<h5 id="context-representation-in-smartphones">Context representation in smartphones</h5>
<p>Knowledge graphs and collective data banks utilize RDF and OWL or their related formats to store contextual data and its relations. Web services utilize different formats such SOAP, WSDL, UDDI <span class="citation" data-cites="WebServices"><a href="#ref-WebServices" role="doc-biblioref">[52]</a></span> or JSON <span class="citation" data-cites="JSON"><a href="#ref-JSON" role="doc-biblioref">[53]</a></span> to communicate data. All of these forms are non-native on smartphone platforms and require parsing before the data can be utilized or manipulated. This places limitations on the utilization of models that use these formats for interacting with context since smartphone applications are developed using different technologies which makes it difficult to integrate traditional context representations into the application design.</p>
<h3 id="sub:smart_apps">Smart Apps</h3>
<p>The word <em>Smart Apps</em> is derived from the word <em>smartphone</em>, which stands for a mobile phone with an operating system that offers features such as a personal digital assistant, a digital camera, a media player, and/or a GPS navigation unit. The word <em>smart</em> in <em>smart apps</em> is used to denote the capability of an app to help users with the completion of their task by utilizing contexts such as location, time, sensor information or offering recommendations and automation which allow the task to be completed in lesser time and/or fewer steps <span class="citation" data-cites="SMARTAPPS"><a href="#ref-SMARTAPPS" role="doc-biblioref">[12]</a></span>. The features and design of smart apps depend on the availability of contextual information. An example of a smart app is Fantastical <span class="citation" data-cites="CalendarFantastical"><a href="#ref-CalendarFantastical" role="doc-biblioref">[18]</a></span>, which allows users to type entries in natural language in a single text box to create events in the calendar instead of interacting with multiple entry fields and UI elements.</p>
<h3 id="sub:intelligent_personal_assistants">Intelligent Personal Assistants</h3>
<p>An intelligent personal assistant is a mobile software agent that can perform tasks or services for an individual. These tasks or services are based on user input, location awareness, and the ability to access information from a variety of online sources (such as weather or traffic conditions, news, stock prices, user schedules, retail prices, etc.). Intelligent personal assistant technology is achieved through the combination of mobile devices, application programming interfaces (APIs), and the proliferation of mobile apps. An intelligent personal assistant can be designed to perform specific, one-time tasks specified by user voice instructions, or to perform ongoing tasks autonomously. One of the key aspects of an intelligent personal assistant is its ability to organize and maintain information such as emails, calendar events, files, and to-do lists.</p>
<h4 id="sub:siri">Siri</h4>
<p>Siri <span class="citation" data-cites="Siri"><a href="#ref-Siri" role="doc-biblioref">[54]</a></span> is an intelligent personal assistant and knowledge navigator developed by Apple for its iOS platform. The application uses a natural language user interface to answer questions, make recommendations, and perform actions by delegating requests to a set of web services. The software adapts to the user’s language usage and searches with use, and returns results that are individualized. Siri allows users to make reservations at specific restaurants, buy movie tickets or get a cab by dictating instructions in natural language. The application integrates with default iOS functionality, such as contacts, calendars and text messages and supports services from providers such as Google, Bing, Yahoo, Wolfram Alpha, Google Maps, Yelp! and Wikipedia. Siri also contains numerous pre-programmed responses to conversational and amusing questions.</p>
<h4 id="sub:google_now">Google Now</h4>
<p>Google Now <span class="citation" data-cites="Google:Now"><a href="#ref-Google:Now" role="doc-biblioref">[13]</a></span> is an intelligent personal assistant developed by Google. It is available within the Google Search mobile application for Android, iOS, and the Google Chrome web browser on personal computers. Google Now uses a natural language user interface to answer questions, make recommendations, and perform actions by delegating requests to a set of web services. Along with answering user-initiated queries, Google Now pro-actively predicts information the user will want based on their search habits, and by utilizing data from users’ other Google services. Google Now is implemented as an aspect of the Google Search application and recognizes repeated actions such as common locations, repeated calendar appointments, and search queries a user performs on the device to display relevant information to the user in the form of ‘cards.’ The application system leverages Google’s Knowledge Graph project<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> to assemble more detailed search results by analyzing their semantic meanings and connections.</p>
<h4 id="sub:cortana">Cortana</h4>
<p>Cortana <span class="citation" data-cites="Cortana"><a href="#ref-Cortana" role="doc-biblioref">[55]</a></span> is an intelligent personal assistant for Windows Phone 8.1 and the Microsoft Band. Cortana’s features include being able to set reminders, recognize natural voice without the user having to input a predefined series of commands, and answer questions using information such as current weather and traffic conditions, sports scores, and biographies from Bing. The ‘Notebook’ is a data collection unit where personal information such as interests, location data, reminders, and contacts are stored for access. Cortana uses this data in order to learn the user’s specific patterns and behaviors and can add information as it learns. The user can view this information and specify what information is collected, which offers greater control over privacy settings compared to other assistants. Users can also delete information from the ‘Notebook’ if they deem it undesirable for Cortana to know.</p>
<h4 id="sub:other_personal_assistants">Data Sources and Mode of Operation</h4>
<p>Intelligent personal assistants work on the principle of analyzing and interpreting data to provide contextually relevant information and services. In order to replicate the functionality of personal assistants, an app needs access to data and resources which it can utilize to formulate the contextual responses to the users’ queries. In the case of Google Now, it has access to data aggregated from all of Google’s diverse services, and needs the user to actively use those services in order to function as intended. Siri does not provide personalized recommendations beyond those obtained from data limited to some services on the device. It however, uses natural language processing based in the cloud to identify the users requests and to provide appropriate responses. Similarly, Cortana utilizes data acquired from the device and Microsoft’s services in order to provide functionality similar to Google Now.</p>
<p>Developing features in apps comparable to personal assistants requires access and analysis of data related to the user’s context, whose availability is limited to a developer. This can be seen through the difference between the advent of smart apps and personal assistants, where smart apps are developed based on using functionality and comparably lesser data. Making such data available to developers is not possible due to concerns about security and privacy, which do not exist for personal assistants as they utilize data within a single ecosystem or tightly coupled ecosystems.</p>
<h2 id="sec:data_sharing_in_smartphone">Data Sharing in Smartphone Applications</h2>
<p><em>“Data! Data! Data! I can’t make bricks without clay!”</em></p>
<p>– <em>Sir Arthur Conan Doyle</em></p>
<p><em>Data sharing</em> can be defined as the ability to share the same data resource with multiple applications or users (collectively called clients) <span class="citation" data-cites="def_datasharing"><a href="#ref-def_datasharing" role="doc-biblioref">[56]</a></span>. It implies that the data is stored or generated in one or more applications on a device and there is some framework or middleware that allows it to be shared between applications.</p>
<p>Unlike applications on traditional operating systems, smartphone applications have a much more restrictive security model called <em>sandboxing</em>. Sandboxing is a security mechanism that separates applications from each other and restricts any unspecified access between them. This prevents one application from corrupting or over-writing another application’s data. This results in aggressive restrictions that limit interactions with other applications. Data sharing is possible only through the use of API’s provided by the system. The following sections discuss the various data sharing mechanisms available in iOS and Android. Apart from the data sharing methods described below, applications cannot utilize or define other APIs, and neither can they directly access data from another app due to the restrictions placed by the sandboxing model.</p>
<h3 id="sub:sharing_common_mime_types">Sharing Common Data Types</h3>
<p>Both iOS and Android support sharing of common data types such as text and images through a dedicated <em>share</em> menu that can send data objects from within an app to other apps. On Android, this is achieved through the Intent and Intent-filter mechanism <span class="citation" data-cites="AndroidIntents"><a href="#ref-AndroidIntents" role="doc-biblioref">[57]</a></span>, whereas on iOS, the same is achieved through UIActivityViewController <span class="citation" data-cites="iOSCoreData"><a href="#ref-iOSCoreData" role="doc-biblioref">[58]</a></span>. Both platforms allow the selected data object to be shared with all applications that have registered the capability to handle the object’s MIME type <span class="citation" data-cites="MIME"><a href="#ref-MIME" role="doc-biblioref"><strong>MIME?</strong></a></span>. The destination of the target app is selected by the system or by the user themselves though a UI element as seen in Fig. <a href="#fig:sharemenu" data-reference-type="ref" data-reference="fig:sharemenu">[fig:sharemenu]</a>.</p>
<figure>
<img src="img/002-sharemenu_android.png" id="fig:sharemenu_ios" alt="Android 4.4" /><figcaption aria-hidden="true">Android 4.4</figcaption>
</figure>
<figure>
<img src="img/002-sharemenu_ios.png" id="fig:sharemenu_android" alt="iOS 8" /><figcaption aria-hidden="true">iOS 8</figcaption>
</figure>
<p>The system populates the sharing list with applications that have explicitly declared the capability to handle the type of context being shared. Applications declaring the ability to handle data objects of type <em>image</em> are displayed in the list shown when an image is selected and shared. In Android, the explicit declaration is mentioned through the applications’ <em>manifest</em> <span class="citation" data-cites="manifest"><a href="#ref-manifest" role="doc-biblioref">[59]</a></span> file, whereas on iOS it is declared programmatically via code.</p>
<p>The system provides the required API’s for handling and sharing commonly used data types such as image, audio, web-pages, and text. Any other data type must be explicitly known and uniformly interpreted by all the apps that want to share data objects of that type. For example, a calendar event can be considered a complex data type available through the system’s calendar API. Events such as a restaurant booking or a movie show are similar to a calendar event, but are not recognized data types. Apps that wish to declare or share these data types cannot guarantee that other apps will correctly recognize and interpret them.</p>
<h3 id="sub:custom_url_uri_schemes">Custom URL/URI schemes</h3>
<p>In computing, a Uniform Resource Locator (URL) is a subset of the Uniform Resource Identifier (URI) that specifies where an identified resource is available and the mechanism for retrieving it. The scheme name (or protocol) of a URL is the first part of a URL. For web pages, the scheme is usually <em>http</em> or <em>https</em>. iOS and Android support some URL schemes related to web-pages, telephony and messaging by default <span class="citation" data-cites="iOS_uri_schemes android_common_intents"><a href="#ref-iOS_uri_schemes" role="doc-biblioref">[60]</a>, <a href="#ref-android_common_intents" role="doc-biblioref">[61]</a></span>. Applications can specify their own custom URL scheme such as <em>myapp://something</em> which is resolved by the system to open the particular functionality within an app associated with the scheme. This allows other apps to communicate with an app through a protocol defined by its URL/URI scheme.</p>
<p>The resolution of URL/URI links is done by the system, which identifies the correct app associated with the scheme and opens it. If there is more than one app associated with a scheme, the system shows a dialog to select an application similar to the dialog shown in the <em>share</em> menu. The system restricts the resolution of some schemes to fixed applications, which cannot be changed. If some user application declares a URL/URI that is identical to a restricted scheme, the default system app is launched instead of the user app. URL handling on Android devices works through the Intents mechanism, where apps register to get launched in response to certain specified actions.</p>
<p>Applications can use custom URL/URI schemes to directly navigate to activities within an app, or to send and receive data. Small amounts of data can be easily encoded into the URL/URI in a way similar to how websites are accessed, though the system does not require network connectivity to resolve these schemes. Applications can behave differently based on the data passed in the URL. For example, the Map app can be sent location coordinates as parameters in the URL to open an activity displaying the location specified by the coordinates on the map. The app that generates the URL/URI needs to be aware of the correct syntax the Map app requires. In general developers are required to know the various schemes and syntaxes required to integrate popular services from other apps. Some developers have created a public library of custom URL/URI schemes [8] supported by various apps as a way for other developers to discover services easily. Using such libraries still requires the developers to be explicitly aware of the exact URL/URI scheme required by the target app in order to interact with it.</p>
<h4 class="unnumbered" id="deep-linking">Deep Linking</h4>
<p>In the context of the Web, deep linking consists of using a hyperlink that links to a specific generally searchable or indexed piece of web content on a website. For example using <em>http://example.com/path/page</em> to navigate to a particular page rather than the home page at <em>http://example.com/</em>. In mobile apps, deep linking consists of using a URI that links to a specific location within a mobile app (<em>exampleApp://location/123456</em>), rather than simply launching the app (<em>exampleApp://</em>).</p>
<p>The greatest benefit of mobile deep linking is the ability for marketers and app developers to bring users directly into the specific location within their app with a dedicated link. Unlike deep links on the web, where the link format is standardized based on HTTP guidelines, mobile deep links do not follow a consistent format. This causes confusion because different sets of links are required to access the same app on different platforms.</p>
<p>Alternate solutions developed include one approach where a smarter deep link is created that triggers the most appropriate response depending on the device being used. A solution developed by AppsFlyer called OneLink <span class="citation" data-cites="onelink"><a href="#ref-onelink" role="doc-biblioref">[62]</a></span> detects the device type and the installed apps and triggers a Web or Mobile deep link or opens the appropriate App Store in case the requested app is not installed on the user device, also known as deferred deeplinking. Another solution proposed by URX called Omnilinks <span class="citation" data-cites="urx"><a href="#ref-urx" role="doc-biblioref">[63]</a></span> requires prefixing a web link with <code>urx.io/</code> to convert it into a deep link, which works across all devices. This routes users into a specific page in an app if that user has the app installed. App Links <span class="citation" data-cites="applink"><a href="#ref-applink" role="doc-biblioref">[64]</a></span> is a deep linking standard developed by Facebook that makes it possible to launch an app containing content shared on Facebook (or another App Links-enabled app). Quixey created AppURL <span class="citation" data-cites="appurl"><a href="#ref-appurl" role="doc-biblioref">[65]</a></span> which is an open standard for deep linking across platforms and also allows search engines to crawl in-app links. Quixey also produces search algorithms for in-app searches that provides results in the form of deep links. For example, if the user searches for “Mexican food,” the user is provided with results from apps that provide restaurant services such as Yelp, GrubHub, OpenTable, and Foursquare, where the results act like a shortcut that take the user directly into that page in the app if it is installed.</p>
<p>Google provides App indexing <span class="citation" data-cites="appindexing"><a href="#ref-appindexing" role="doc-biblioref">[66]</a></span>, which allows developers to connect pages from their website with specific content within their smartphone app on Android. This enables smartphone users who have the app installed to open it directly from relevant mobile search results on Google. Developers can make it possible for Google Search to open specific content in their app by providing intent filters for relevant activities. This requires configuring both the app and the website along with a description of how they are related to to oder to show <em>Open in app</em> deep links in search results. This feature is limited to apps that also have a website that Google can search and index. Currently, only Google search can make use of app indexing. Such kinds of contextual information sharing is not available to all applications in general.</p>
<h3 id="sub:telephony_messaging_and_location">Telephony and Messaging data</h3>
<p>Applications can share data inherently through the use of various options made available by system. Commonly required data such as Calendar and Contacts are provided as part of standard APIs that are made available to developers. <em>EventKit</em> <span class="citation" data-cites="eventkit"><a href="#ref-eventkit" role="doc-biblioref">[67]</a></span> on iOS provides developers access to calendar and reminders, which lets applications interact with the user’s calendars and reminders. For accessing contacts, iOS has <em>Address Book</em> <span class="citation" data-cites="addressbook"><a href="#ref-addressbook" role="doc-biblioref">[68]</a></span> that provides a centralized database of the user’s contacts that any application can access and update. Android features Content Providers <span class="citation" data-cites="ContentProvider"><a href="#ref-ContentProvider" role="doc-biblioref">[69]</a></span> that act like a centralized database providing access to other apps through the use of specific APIs. Data such as contacts and calendars are made available to other apps by exposing their content provider API. Every version of Android includes these two Content Providers by default, and others can be added by apps when they are installed on a device. Fig. <a href="#fig:calendarprovider" data-reference-type="ref" data-reference="fig:calendarprovider">[fig:calendarprovider]</a> shows the Calendar Provider which is a Content Provider that provides access to calendar data on Android. Accessing Content Providers for user apps requires permission and access to the Content Provider’s URL/URI. There is no abstract mechanism whereby apps can discover and/or connect to Content Providers already present on the device.</p>
<h3 id="sub:absence_of_traditional_data_sharing_methods">Comparison with Traditional Data Sharing Methods</h3>
<p>Android and iOS, despite being based on or closely related to POSIX based systems<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> do not allow apps to use traditional data sharing mechanisms such as file-copy, pipes or data dumps.</p>
<h3 id="sub:file_picker_or_selectors">Document Pickers</h3>
<p>A document picker allows an application to request selection of data objects through another app. Common uses include selecting image files or contacts within an app that does not have access to these resources. Android uses the Storage Access Framework (SAF) <span class="citation" data-cites="saf"><a href="#ref-saf" role="doc-biblioref">[70]</a></span> that allows users to browse and open documents, images, and other files across all of their their preferred document storage providers. iOS has a similar mechanism known as Document Picker <span class="citation" data-cites="ios_documentpicker"><a href="#ref-ios_documentpicker" role="doc-biblioref">[71]</a></span> that lets users select documents from outside an app’s sandbox.</p>
<h3 id="sub:exclusive_to_ios">Methods exclusive to iOS</h3>
<h4 id="sub:pasteboard">Pasteboard</h4>
<p>iOS has a common data dump, called UIPasteBoard <span class="citation" data-cites="pasteboard"><a href="#ref-pasteboard" role="doc-biblioref">[72]</a></span> which acts like a clipboard sharing service. Apps can place data on the pasteboard that is accessible globally. Pasteboards can be given unique identifiers that can be shared between apps. The data on a pasteboard persists even if the app that used it is terminated. Pasteboards are flexible in the size of data to be shared. However, any applications accessing the pasteboard can overwrite or change its contents.</p>
<h4 id="airdrop">Airdrop</h4>
<p>AirDrop <span class="citation" data-cites="ios_ipc"><a href="#ref-ios_ipc" role="doc-biblioref">[73]</a></span> is used to share photos, documents, URLs, and other types of data with apps and nearby devices. It uses peer-to-peer networking to find nearby devices and connect to them.</p>
<h4 id="shared-keychain">Shared Keychain</h4>
<p>A ‘keychain’ <span class="citation" data-cites="keychain"><a href="#ref-keychain" role="doc-biblioref">[74]</a></span> is an encrypted container that holds passwords for multiple applications and secure services, used by iOS as a password management system [7]. Applications can store data securely to a shared keychain which is accessible only to other applications using the same app ID prefix. The amount of data stored in the keychain is limited as it is not suitable for storing large amounts of data.</p>
<h4 id="icloud---shared-storage">iCloud - Shared Storage</h4>
<p>Developers can use the ‘iCloud’ service <span class="citation" data-cites="icloud"><a href="#ref-icloud" role="doc-biblioref">[75]</a></span> to store large amounts of data, which can be accessed by apps having the same ID prefix. Therefore, apps not having the same ID prefix and looking to share data must use third-party libraries or frameworks which will allow them to share data with other apps that agree to use the same framework.</p>
<h3 id="sec:methods_exclusive_to_android">Methods exclusive to Android</h3>
<h4 id="sub:intent_and_intent_filters">Intent and Intent Filters</h4>
<p>An Intent <span class="citation" data-cites="AndroidIntents"><a href="#ref-AndroidIntents" role="doc-biblioref">[57]</a></span> is an abstract description or an <em>intention</em> of the operation to be performed. Intents are asynchronous messaging objects used to request functionality from other app components, which allows an app component to interact with other components within the same application as well as with components in other applications. An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities.</p>
<p>Intents are generally used to launch Activities,<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> to interact with services, and to send broadcast messages. Android supports explicit and implicit intents. An application can define the target component directly in the intent (explicit intent) or ask the Android system to evaluate registered components based on the intent data (implicit intents).</p>
<h5 class="unnumbered" id="explicit-intents">Explicit Intents</h5>
<p>Explicit intents explicitly define the component which should be called by the Android system, by using the Java class as identifier. Explicit intents specify the component to start by its fully-qualified name.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> Listing <a href="#lst:explicit_intent" data-reference-type="ref" data-reference="lst:explicit_intent">[lst:explicit_intent]</a> shows a function in <em>app1</em> that starts an activity in <em>app2</em>. Without the fully qualified name and necessary permissions, it is not possible to start or interact with activities from other apps. When an explicit intent is used to start an activity or service, the system immediately starts the app component specified in the Intent object.</p>
<figure id="lst:explicit_intent">
    <pre><code>package msc.prototype.demo.app1;
someFunction() {
  Intent intent = new Intent(this, &quot;msc.prototype.demo.app2.Activity);
  intent.putExtra(&quot;Value1&quot;, &quot;This value one for ActivityTwo &quot;);
  intent.putExtra(&quot;Value2&quot;, &quot;This value two ActivityTwo&quot;);
  startActivity(intent);
}</code></pre>
    <figcaption>Starting an activity in another app by using an explicit intent</figcaption>
</figure>
<h5 class="unnumbered" id="implicit-intents">Implicit Intents</h5>
<p>Implicit intents declare a general action to perform which is handled by a component from any app that has declared the capability to perform the requested action. For example, to show the user a location on a map, an implicit intent can be used to request another app to show a specified location on a map. When using an implicit intent, the Android system finds the appropriate component to start by comparing the contents of the intent to the intent filters declared in the manifest file of other apps on the device. If the intent matches an intent filter, the system starts that component and delivers it the intent object. If multiple intent filters are compatible, the system displays a dialog so the user can pick which app to use. This is also how a share menu is populated by the system. Fig. <a href="#fig:intent-filter" data-reference-type="ref" data-reference="fig:intent-filter">[fig:intent-filter]</a> shows how an implicit intent is handled by the system to open another application. The <em>onCreate</em> method is used to open an application’s activity and perform initialization operations. Listing <a href="#lst:implicit_intent" data-reference-type="ref" data-reference="lst:implicit_intent">[lst:implicit_intent]</a> shows an example of an implicit intent, used to send <code>ACTION_SEND</code> text <code>MIME type PLAIN_TEXT_TYPE</code> to other apps capable of handling text.</p>
<figure>
    <pre><code>Intent intent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType(HTTP.PLAIN_TEXT_TYPE);
startActivity(intent);</code></pre>
    <figcaption>Sending contents to other apps by using an implicit intent</figcaption>
</figure>
<h5 class="unnumbered" id="intent-filters">Intent Filters</h5>
<p>An Intent Filter specifies the type of intents that an app component wants to respond to. An intent filter declares the capabilities of its parent component such as what it can do and what types of broadcasts a receiver can handle. It opens the component to receiving intents of the advertised type, while filtering out those that are not meaningful for the component. For example, declaring an intent filter for handling text shows the app in the share menu whenever some text is selected. An intent filter is declared in the app’s manifest. If an activity does not contain an intent filter, it can be started only with an explicit intent. Listing <a href="#lst:intent_filter" data-reference-type="ref" data-reference="lst:intent_filter">[lst:intent_filter]</a> shows an intent filter that tells the Android system to launch the given activity launching the app.</p>
<figure>
    <pre><code>&lt;activity android:name=&amp;quot;MainActivity&amp;quot;&amp;gt;
    &amp;lt;!-- This activity is the main entry, should appear in app launcher --&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;
        &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;</code></pre>
    <figcaption>Declaring an intent filter that opens the activity upon app launch</figcaption>
</figure>
<h5 class="unnumbered" id="intent-data">Intent Data</h5>
<p>An Intent object carries information that the Android system uses to determine which component to start (such as the exact component name or component category that should receive the intent), and information that the recipient component uses in order to properly perform the action (such as the action to take and the data to act upon). An intent primarily contains the name of the component to start, the action to perform, a URI object that references the data or the MIME type of the data, a category about the kind of component required to handle the intent, flags that define the metadata and extras, which are key-value pairs containing additional information required to complete the action. Intent objects can be used to marshal data across apps and processes, provided that the apps at both side of the connection are aware of the exact type and contents of the data object.</p>
<h4 id="broadcast-receivers">Broadcast Receivers</h4>
<p>Broadcast Receivers <span class="citation" data-cites="broadcast"><a href="#ref-broadcast" role="doc-biblioref">[76]</a></span> respond to broadcast messages (also called events or intents) from other applications or from the system itself. For example, applications can initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use. The broadcast receivers declared in the apps will intercept this communication and will initiate appropriate action. The broadcast receivers are declared by an app in its manifest, and must contain the details of the type of messages they wish to receive. To receive updates or information from another app’s broadcasts, the app must know and declare the correct broadcast identifier in its manifest.</p>
<h4 id="sub:services">Services</h4>
<p>A Service <span class="citation" data-cites="service"><a href="#ref-service" role="doc-biblioref">[77]</a></span> is an application component that can perform long-running operations in the background and does not provide a user interface. Another application component can start a service and it will continue to run in the background even if the user switches to another application. Additionally, a component can bind to a service to interact with it and even perform interprocess communication (IPC). For example, a service might handle network transactions, play music, perform file I/O, or interact with a content provider while executing in the background. Just like with activities, other apps must know the fully-qualified name of the service, and must have sufficient permissions required to access and interact with it.</p>
<h4 id="sub:content_providers">Content Providers</h4>
<p>Content Providers <span class="citation" data-cites="ContentProvider"><a href="#ref-ContentProvider" role="doc-biblioref">[69]</a></span> are used to encapsulate data, and are the standard interface that connects data in one process with code running in another process. A Content Provider represents data as one or more tables similar to a relational database. An application accesses the data from a Content Provider with a Content Resolver object. The Content Resolver is a single global object per application that provides access to Content Providers. The Content Resolver accepts requests and resolves these by directing them to the Content Provider, which acts as an abstraction layer between the repository of data and its external appearance as tables. The Content Resolver stores a mapping from authorities (URIs) to Content Providers, which provides a simple and secure means of accessing other applications’ Content Providers in the Android ecosystem. Fig. <a href="#fig:content_provider" data-reference-type="ref" data-reference="fig:content_provider">[fig:content_provider]</a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> shows a Content Provider and its defined interfaces that apps use to interact with the data.</p>
<p>The Content Resolver includes the CRUD (create, read, update, delete) methods corresponding to the abstract methods (insert, query, update, delete) in the Content Provider class. The Content Resolver does not know the implementation of the Content Providers it is interacting with as each method is passed as an URI that specifies the Content Provider to interact with. The Content Resolver object is situated in the application’s process and the Content Provider object is in the application that owns the provider, and both automatically handle the required inter-process communication needed to send queries and results. A content URI is an argument passed that contains the URI used to identify data in a Content Provider. Content URIs include the symbolic name of the entire provider (its URI authority) and a name that points to a table (a path in the data). The Content Resolver object parses out the URI’s authority, and uses it to <em>resolve</em> the provider by comparing the authority to a system table of known providers. The Content Provider uses the path part of the content URI to choose the table to access. The URI, the path and its parsing can be defined through code, which allows handling the URI depending on the requirements. Listing <a href="#lst:content_provider" data-reference-type="ref" data-reference="lst:content_provider">[lst:content_provider]</a> shows a URI authority corresponding to a Content Provider where <code>msc.prototype.demo.contentprovider</code> is the provider’s authority, and <code>context</code> is the table’s path. The string <code>content://</code> is the scheme, and is always present as it identifies the URI as a content URI.</p>
<figure>
    <pre><code>content://msc.prototype.demo.contentprovider/contexts</code></pre>
    <figcaption>Example of a Content URI for accessing the \textit{contexts} table within a Content Provider</figcaption>
</figure>
<p>To retrieve data from a provider, an application needs <em>read access permission</em> for the provider, which cannot be requested at run-time. The app needs to specify this permission in its manifest using the <code>&lt;uses-permission&gt;</code> element and the exact permission name defined by the provider. The exact name of the read access permission and any other access permissions used by the provider may be available in an app’s documentation if the developer has explicitly decided to share it with others. If the Content URI or access permissions are unavailable, the app cannot access the data within the Content Provider. If a provider’s application doesn’t specify any permissions, then other applications do not have access to the provider’s data.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<h1 id="the-contextual-data-sharing-model">The Contextual Data Sharing Model</h1>
<h2 id="context-definition">Context Definition</h2>
<p><em>“Context is worth 80 IQ points.”</em></p>
<p>– <em>Alan Kay</em></p>
<h3 id="introduction-2">Introduction</h3>
<p>Different apps have access to different kinds of information. Even if this information were to be shared, apps need to understand the information’s context in order to utilize the information to present related services. For example, if the <em>Movie</em> booking app shared the <em>Movie</em> date/time information with other apps, without a proper reference to the context (in this case - a movie) the apps will only see the information as representing time. In order to utilize the information contextually, it is important to refer to context for any data. Along with a reference, the app also needs to access the various fields of information available in relation to the given context so that it can provide services designed around that information. For example, the <em>Movie</em> context should always have the <em>Movie</em> title, the show time, and the theater <em>Location</em> as key pieces of information that make up the context. Other information such as for ticket and seats is optional, and only adds to the contextual information already present about that event. Therefore, in order to utilize contextual information, an app needs to recognize the context and the fields of information available within that context.</p>
<p>Different apps can represent the same context in different ways. It is important to ensure that all apps interpret contextual information in a similar way. This is important for sharing contextual information across apps and to prevent confusion that may arise from ambiguity in the information. For example, some apps may assume that the <em>Movie</em> context contains ticket information, while other apps may not. This will create problems when these apps share contextual information that both interpret differently. The sharing and understanding of contexts in apps that look for fields of information not available or not supported by other apps creates different uses of context that introduce differences in the sharing of contextual information.</p>
<p>The apps use Context Definitions to prevent such problems and enable sharing of contextual information in a uniform way. Using Context Definitions allows the apps to define and share contextual information that is interpreted similarly across all apps that use the definition. This provides a common information format that is structured and understood by all apps using the same definition, which makes sharing of information easier.</p>
<h3 id="objectives">Objectives</h3>
<p>These are the three main objectives fulfilled by Context Definitions:</p>
<ol>
<li><p>To allow apps to recognize the context of shared information;</p></li>
<li><p>To represent the various fields that are defined or present for a particular context;</p></li>
<li><p>To define a structure for contextual information that different apps use to represent contextual information in a uniform format.</p></li>
</ol>
<h3 id="definition">Definition</h3>
<p>A formal definition of context used for the purpose of this research is based on extending Dey’s <span class="citation" data-cites="ContextDef"><a href="#ref-ContextDef" role="doc-biblioref">[22]</a></span> definition: <em>Context comprises of any information related to or affecting the users activities and tasks. This information includes time, location, weather, sensor information, and all information the user is presented with or enters on or related to a task.</em></p>
<p>The information shown by apps to the user and the inputs and choices made by the user also constitute contextual information as they are relevant to the task at hand. This information can be used contextually and therefore also comprises useful context. The app responsible for displaying or accepting such information is tasked with declaring the contextual nature of acquired information.</p>
<h3 id="representation">Representation</h3>
<p>Contextual information can be broadly classified into different types based on their use. The different contexts are represented by a schema based on the information they represent. Each schema is referred to by a unique name and a set of fields that attribute the different information pertaining to the context. Apps use this schema as the definition for that particular context when accessing related contextual information.</p>
<p>Listing <a href="#lst:SchemaEvent" data-reference-type="ref" data-reference="lst:SchemaEvent">[lst:SchemaEvent]</a> below shows the schema for the <em>Event</em> context :</p>
<figure>
<pre id="lst:SchemaEvent" data-caption="Schema for \textit{Event} Context" label="lst:SchemaEvent"><code>Event {
    Title
    Date/Time
    Location
    Contacts
}</code></pre>
<figcaption>Schema for <em>Event</em> Context</figcaption>
</figure>
<p>The schema has a unique name called “<em>Event</em>” which defines the nature of contextual information contained within it. The title, date/time, <em>Location</em> (representing the GPS co-ordinates) and <em>Contacts</em> (a Contact object similar to the phonebook) are used to refer to the information represented by an <em>Event</em> context. These fields together provide information that tells which Event (title) is taking place where (Location) and when (date/time), and who will be attending (Contacts).</p>
<p>Apps use the definition to instantiate context objects for that particular type of context. When an app uses an <em>Event</em> object, it uses the schema or definition to interpret the information available within the <em>Event</em> object. Whenever it refers to an <em>Event</em> context, it knows that there are title, date/time, <em>Location</em> and <em>Contacts</em> fields accessible to it. By making this definition of <em>Event</em> context uniform across different apps, the representation of an <em>Event</em> object and its associated contextual information is also uniform across all apps. This ensures that different apps represent a particular context in the same way irrespective of how it was generated or acquired.</p>
<h3 id="extending-context">Extending context</h3>
<p>Certain contexts can be modeled as an extension to existing contexts. This allows us to add more information to existing contexts, and also makes representing additional contexts easier. The extended context only has to define the additional fields. The fields from the base or parent context are implicitly included in the schema of the extended context. This creates a relation or compatibility between contexts which reflects how contexts are used in real-world use cases.</p>
<p>For example, a schema for <em>Movie</em> context is be described in Listing <a href="#lst:SchemaMovieInfo" data-reference-type="ref" data-reference="lst:SchemaMovieInfo">[lst:SchemaMovieInfo]</a>. Some of the fields are similar to the schema of <em>Event</em> context. The <em>Movie</em> Title is similar to the <em>Event</em> title, the show date/time is similar to the <em>Event</em> date/time, the theater <em>Location</em> is similar to <em>Event’s</em> <em>Location</em> and both schema have a contacts field representing the people that will be attending the said event. The Ticket and Seat Information fields in <em>Movie</em> context do not have a corresponding field in <em>Event</em> context, and are therefore unique to the <em>Movie</em> context. This shows that in terms of contextual information, the <em>Movie</em> context is similar to the <em>Event</em> context, and shares some of its fields. Contextually we can say that <em>a <em>Movie</em> is an Event</em>. Which means that a <em>Movie</em> context is a special case of an <em>Event</em> context, or that a <em>Movie</em> is a type of <em>Event</em>. Therefore we model the schema for <em>Movie</em> to be an extension of the schema for <em>Event</em>. We define the schema for <em>Movie</em> as shown in Listing <a href="#lst:SchemaMovie" data-reference-type="ref" data-reference="lst:SchemaMovie">[lst:SchemaMovie]</a> using only the fields that are added such as Ticket and Seat information. The other fields belonging to <em>Event</em> context are implicitly included in <em>Movie</em> context.</p>
<figure>
    <pre id="lst:SchemaMovieInfo" data-caption="Information in \textit{Movie} Context" label="lst:SchemaMovieInfo"><code>Movie {
    Movie Title
    Show Date/Time
    Theater Location
    Attending Contacts
    Ticket Information
    Seats
}</code></pre>
<figcaption>Information in <em>Movie</em> Context</figcaption>
</figure>
<figure>
<pre id="lst:SchemaMovie" data-caption="Information in \textit{Movie} Context" label="lst:SchemaMovie"><code>Movie (extends Event) {
    // fields implicitly included from Event
    Movie Title
    Show Date/Time
    Theater Location
    Attending Contacts

    //fields defined
    Ticket
    Seats
}</code></pre>
<figcaption>Information in <em>Movie</em> Context</figcaption>
</figure>
<p>An app instantiating a <em>Movie</em> context object has access to all fields related to <em>Movie</em> context. This includes the fields implicitly inherited from the <em>Event</em> context, and the fields declared in the <em>Movie</em> schema. For apps, all fields in the <em>Movie</em> schema, including those inherited from <em>Event</em> schema appear as part of the <em>Movie</em> schema. When using the <em>Movie</em> context object, the app will store the <em>Movie</em> title in the title field, the theater <em>Location</em> in the <em>Location</em> field, and the show time in Date/Time field.</p>
<p>If we structure the contexts according to how they extend other contexts, we get a tree representing the hierarchy of contexts. The root of this tree is an abstract entity called Context, which acts as a common ancestor. Having a common ancestor and a hierarchy allows for generalization of contexts through which contexts can be reused based on their placement in the hierarchy. For example, if a Calendar app provides services for <em>Event</em> context, it will not require modifications and duplication of effort in order to provide the same services for <em>Movie</em> context. With generalization, the Calendar app will receive an instance of the <em>Movie</em> context as an <em>Event</em> context which it can recognize and act on. This allows the Calendar app to provide services for <em>Event</em> context as well as all contexts that have extended from <em>Event</em> without additional modifications or the need to recognize the new contexts.</p>
<h4 class="unnumbered" id="relation-between-extended-contexts">Relation between extended contexts</h4>
<p>A context hierarchy as depicted in Fig. <a href="#fig:extendedhierarchy" data-reference-type="ref" data-reference="fig:extendedhierarchy">[fig:extendedhierarchy]</a> contains the context <span class="math inline"><em>P</em></span> with all contexts extending <span class="math inline"><em>P</em></span> situated below it. The context <span class="math inline">$C\textsubscript{1}$</span> and <span class="math inline">$C\textsubscript{2}$</span> extend <span class="math inline"><em>P</em></span>, and context <span class="math inline">$C\textsubscript{3}$</span> extends <span class="math inline">$C\textsubscript{1}$</span>. The extending context <span class="math inline"><em>P</em></span> is called the parent of the extended context <span class="math inline">$C\textsubscript{1}$</span>. Also <span class="math inline">$C\textsubscript{1}$</span> is called a sub-type of <span class="math inline"><em>P</em></span>.</p>
<p>The context <span class="math inline">$C\textsubscript{3}$</span> can be generalized to <span class="math inline">$C\textsubscript{1}$</span>, and <span class="math inline">$C\textsubscript{2}$</span> can be generalized to <span class="math inline"><em>P</em></span> as they are the children of the respective contexts. Therefore, we can generalize <span class="math inline">$C\textsubscript{3}$</span> to <span class="math inline"><em>P</em></span> as relations are associative.</p>
<p>In general, all contexts situated below <span class="math inline"><em>P</em></span> in the hierarchy can be generalized as instances of <span class="math inline"><em>P</em></span> since it is their common ancestor. Therefore, if a service is designed to handle context <span class="math inline"><em>P</em></span>, and it receives any context <span class="math inline">$C\textsubscript{x}$</span> that has been extended from <span class="math inline"><em>P</em></span> or any of its descendants, it will receive the context object as an instance of context <span class="math inline"><em>P</em></span>. While accessing this context object, it will have access to only those fields defined in the schema for <span class="math inline"><em>P</em></span>. Thus, the service works with P and all its descendants <span class="math inline">$C\textsubscript{x}$</span> in the hierarchy without modifications or special handling. This allows for contexts to be extended freely while still allowing apps that handle a particular context to receive and work with new contexts extended from it.</p>
<h5 id="single-inheritance">Single inheritance</h5>
<p>To simplify the hierarchy and reduce complexity, a context can extend only one other context. If a context were to extend more than one parent, it could create confusion regarding access to similarly named fields. For example, context A contains a field called Title. Context B and C both extend A and inherit the Title field. Context D extends both context B and context C, and inherits the Title field from both of them. Now when an object of context D is generalized to an instance of context A, it creates ambiguity regarding the field Title. There are two copies of the Title field, inherited from context B and C which can be used to represent the Title field. In this case, it is not clear whether the Title field inherited from B should be used or the one from C. This leads to confusion and complexity in design, which can be avoided by forcing a context to extend a single context only. This problem is also known as the diamond inheritance problem which is one of the complications associated with multiple inheritance <span class="citation" data-cites="JavaMultipleInheritance"><a href="#ref-JavaMultipleInheritance" role="doc-biblioref">[78]</a></span>.</p>
<h3 id="embedding-context">Embedding context</h3>
<p>Contexts that represent a part of the contextual information of another context are embedded as sub-contexts. The embedded context acts like an attribute of the parent context while having its own distinct schema and definition. In that case of <em>Event</em> context, a <em>Location</em> context provides information about where the <em>Event</em> is taking place, and is therefore embedded in the schema of the <em>Event</em> context. An app referring to the <em>Location</em> in an <em>Event</em> context object will be aware of <em>Location</em> being a separate context and will be able to access all of its fields. The Location field acts as a container that holds all the information about a particular location associated with the Event context. The schema for the <em>Location</em> context is given in Listing <a href="#lst:SchemaLocation" data-reference-type="ref" data-reference="lst:SchemaLocation">[lst:SchemaLocation]</a>. By including the sub-context within the schema of the main context, apps have access to related contextual information within a single object.</p>
<figure>
<pre id="lst:SchemaLocation" data-float="" data-caption="Schema for \textit{Location} Context" label="lst:SchemaLocation"><code>Location {
    placename
    co-ordinates(lat,lon)
}</code></pre>
<figcaption>Schema for <em>Location</em> Context</figcaption>
</figure>
<p>The embedded contexts can be updated without knowledge of the contexts that embed them. For example, an app that provides location-based services such as navigation, that updates the co-ordinates in a <em>Location</em> context to denote a particular place. If this information is not linked with the <em>Event</em> contexts taking place at that particular location, the contexts will have outdated <em>Location</em> co-ordinates. By linking <em>Location</em> and <em>Event</em> contexts, updates to any instance of <em>Location</em> context are reflected across all <em>Event</em> instances that use the particular <em>Location</em> context. An app can add or update information to a context without being aware of it being embedded in another context. For example, an app can access and use <em>Location</em> context objects without being aware of how certain contexts like <em>Event</em> embed <em>Location</em> in their schema.</p>
<p>If we create a tree based on how contexts are embedded, we get a figure like the one in Fig. <a href="#fig:embed" data-reference-type="ref" data-reference="fig:embed">[fig:embed]</a>. The contexts at the top are those that do not embed any other context, and are called Simple contexts. Those that embed other contexts are situated below the contexts they embed and are called Complex contexts. Apps that use complex contexts must be aware of all sub-contexts in order to access all the contextual information associated with that context. Using a simple context does not require knowledge of contexts that embed it since the contextual information in a simple context is independent of the contexts that embed it.</p>
<p>Services from apps that handle simple contexts can be utilized by apps that offer services for complex contexts. This allows re-use of functionality and sharing of contextual information in an efficient way. For example, even though the <em>Event</em> context embeds <em>Contact</em> contexts in its schema, it does not have to provide management of contacts. This service is provided by the Phonebook app which allows users to add and update contact information, which is then automatically reflected in the Contact context in an instance of <em>Event</em> context.</p>
<h3 id="example-use-case-movie-ticket-booking">Example Use Case: Movie Ticket Booking</h3>
<p>In the <em>Movie</em> booking use case if the apps use Context Definitions to identify and share contextual information, the resulting user experience becomes simpler and better as the apps use the available contextual information to offer related services. The effort required to access and utilize the contextual information becomes significantly less compared to the apps trying to acquire this information on their own. By extending and embedding contexts, the user can use more contextual services with less effort for app developers to provide such services.</p>
<p>The Calendar app that provides notifications for <em>Event</em> contexts will also provide notifications for <em>Movie</em> contexts since it is extended from Event. This enables the user to use Calendar services like notifications and reminders for <em>Movies</em>. The <em>Location</em> services provided by a Map application are based on using the <em>Location</em> context. The <em>Event</em> context embeds a <em>Location</em> context in its schema, and which is implicitly included in <em>Movie</em>. By using this <em>Location</em> field, the Map application can provide directions to the theater without requiring the user to input this information. This saves effort and duplication of information, and provides easier navigation for the user. <em>Contacts</em> are handled by the Phonebook app that offers users the ability to change contact information. A change or update to a particular contact is reflected across all contexts that embed it. If a particular contact was added to the <em>Movie</em> context, and the contact information was changed by the user through the Phonebook, the contact in the <em>Movie</em> context will also reflect this updated information. This allows for up-to-date information to be available across all shared contexts and allows apps to share and update information freely. The <em>Movie</em> booking app only has to create the <em>Movie</em> context related to the ticket booking. Other services such as notifications and navigation are provided by other apps without being aware of how the <em>Movie</em> context was created or updated. This allows for a variety of related services to work together on shared contextual information without being aware of how other service use the same or related contexts.</p>
<h3 id="responsibility-of-owning-context-definitions">Responsibility of owning Context Definitions</h3>
<p>While definitions form an important aspect of recognizing, declaring and using contexts, it is important to note who manages the creation and handling of definitions. While we provide no recommendation as to who should create definitions, it is important to note from an implementation point of view that the definitions have to be available at the system level as well as to app developers to include in their apps. Therefore some level of involvement from OS manufacturers may be necessary in order to get these definitions on devices and in API’s related to the app development.</p>
<h3 id="summary">Summary</h3>
<p>A Context Definition is used to represent contexts uniformly across apps and devices. A definition constitutes a schema with a unique name and fields that make up the contextual information associated with that particular type of context. Apps use the context definition to initialize context objects of that context type. A context can extend other contexts, which implicitly includes all fields from the parent context in its schema. While the context definition only contains the additional fields defined, apps can also access the implicitly included fields in the context object. A context can embed other contexts, where the embedded context is used as a field representing contextual information about the main context. Extending and embedding contexts allows reuse of functionality, information and services. This makes it easy to develop apps for contexts as services can reuse other services that handle a context without dependence on how the other contexts extend or embed it.</p>
<h2 id="context-database">Context Database</h2>
<p><em>“Knowledge is of two kinds. We know a subject ourselves, or we know where we can find information on it.”</em></p>
<p>– <em>Samuel Johnson</em></p>
<h3 id="introduction-3">Introduction</h3>
<p>Context Definitions allow an app to structure contextual information through a schema which other apps can interpret and understand. After an app has identified or created contextual information, it needs to store the context so that it can retrieve and/or act on it later. The Context Database allows apps to persist contextual information between uses. The Context Database acts like a central repository, where apps can save and retrieve contexts. The app that generates the context inserts it to the Context Database and other apps query the Context Database to retrieve this information at later times. The saving and retrieval of contextual information is asynchronous, which allows apps to access contextual information when they need it.</p>
<h3 id="overview">Overview</h3>
<p>The Context Database stores contextual information using Context Definitions, which allows for easier sharing of contextual information between smartphone applications. The Context Database assumes responsibility for management and storage of the contexts. It will store contexts generated by an app even after the app has been uninstalled. This preserves the contextual information on a device which would have been otherwise lost. Apps can add or modify contexts in the Context Database and can share them with other apps indirectly through the Context Database.</p>
<h3 id="design-and-structure">Design and Structure</h3>
<p>The design and structure of the Context Database is based on the type of database or data store used in the implementation. The features and services supported or provided by the database software are be used to determine the types of queries the Context Database supports. In general, the database software should allow CRUD (Create, Request, Update, Delete) operations for a basic working of the Contextual Data Sharing Model. This includes a way to add contexts to the database, to query contexts based on their type, update context entries in the database and a way to delete contexts.</p>
<p>The Context Database should be managed by the system so as to maintain independence from any particular app. On most implementation platforms, this also includes implementing the Context Database outside the memory space of any user app. This safeguards the Context Database against any malicious processes that may crash the database or corrupt data. If the smartphone operating system uses Sandboxing to isolate process data, it can be used for additional security measures.</p>
<p>The location of the Context Database does not have an impact on the contextual data sharing model, but can potentially have some impact on the user experience. The actual storage backend depends on the implementation and can be based in the cloud, or in a local data store.</p>
<h3 id="deleting-contexts">Deleting Contexts</h3>
<p>Apps are prohibited from deleting contexts in the Context Database due to security concerns. The deletion of contexts in the Context Database is handled by the system. This is done to prevent loss of information and to prevent misuse of the deletion operation by apps. If apps are allowed to delete contexts from the Context Database, it can lead to complications and loss of information. For example, if some app no longer requires a context and deletes it, it can lead to loss of information for another app that may still be using the same context. Also deletion causes permanent loss of information which could have been useful in the future. In cases where there is a link or a relation between contexts such as embedding, the deletion can cause errors. If a context being deleted is referenced as a sub-context in another context, it will lead to loss of contextual information. This can affect the operations when querying for the context next time, as the query may return a reference to a non-existing context which will cause errors, and may stall database operations or crash the app.</p>
<h4 id="factors-affecting-efficiency">Factors affecting efficiency</h4>
<p>The size of the Context Database will have an impact on performance of queries. A database with more records (having greater size) will take more time to execute the same query than a database with fewer records. To keep the database within an acceptable range of values, the Context Database manages the deletion of contexts through a Deletion Policy. The Deletion Policy is used to manage the size of the database and to keep the average query execution time under permissible values. The time taken by a query to successfully execute depends on the number of records, device configuration and app usage. The device configuration is fixed, and cannot be changed. A high specification device can execute complex queries faster than a comparably lower specification device. Therefore the effect of device configuration on query time will be fixed. The app usage depends on user interactions, which can vary greatly and are difficult to classify into expected user interaction patterns. Multiple apps accessing the Context Database simultaneously will also have an impact on its performance. Therefore, the only factor which is manageable and can be used to keep the Context Database operating efficiently is managing the size of the database.</p>
<h4 id="deletion-policy">Deletion Policy</h4>
<p>The Deletion Policy is activated whenever the size of the database or the number of contexts reaches some <em>threshold</em> value <span class="math inline"><em>t</em></span> that is determined as the maximum size of the database for which the average query time is within an acceptable range. The value of <span class="math inline"><em>t</em></span> will vary between devices depending on the specification, use of apps and available space.</p>
<p>The Deletion Policy is an implementation consideration addressing the following points:</p>
<ol>
<li><p><em>What - Selecting contexts to delete</em>: The Deletion Policy selects the contexts to be deleted based on some parameter like time, size, cost or need which marks the contexts to be deleted.</p></li>
<li><p><em>When - Condition to trigger deletion</em>: Along with the value of <span class="math inline"><em>t</em></span>, it is important to consider other activities that will affect when the deletion can be safely run. If some apps are querying contexts in the database, then the deletion policy should be stalled until such apps have finished querying. Also, the phone state, active processes and performance and battery life considerations should also be used to come up with an optimum time for initiating the deletion.</p></li>
<li><p><em>How - Handling context relationships and conflicts</em>: If a context entry about to be deleted has a sub-context, should that be deleted as well? Or if the context is a sub-context of some other context, what should be done about the reference. Such considerations can be affected by the implementation platform and backend software used to implement the Context Database. In general, the following cases will help when implementing the Deletion policy:</p>
<ul>
<li><p>When the context to be deleted has a sub-context;</p></li>
<li><p>When the context to be deleted itself is a sub-context;</p></li>
<li><p>When the context to be deleted has some complex relationship with another context.</p></li>
</ul></li>
</ol>
<h3 id="performance-considerations">Performance Considerations</h3>
<p>The apps using the contextual data sharing model will be interacting with the Context Database whenever they need contextual interactions. In some use cases, this interaction can happen on a regular basis. Multiple apps can try to access the contextual information in the Context Database simultaneously. The user experience in many apps is dependent on the use of contextual information. For example, in Calendar the Events are shown on screen in some format. For this, the app must query the Context Database to retrieve all the Events. Simultaneously, another app may also be requesting Events from the Context Database, to check if there is an upcoming Event for the day. Various other apps may also query the Context Database for different purposes. If the Context Database does not respond in a specified time period, it can affect the UI interactions of the app. If there is a delay in returning the Events to Calendar, then the user may notice a time gap where nothing is happening on screen, or things are being updated slowly. To prevent such delays and to offer a smooth user experience across apps, it is necessary that the Context Database has to be efficient in its queries, returning the requested results to apps in a shorter time period, which allows for faster UI interactions. To make the efficient use of available resources, the database design and schema should be kept simple so as to not impact the system performance.</p>
<h3 id="summary-1">Summary</h3>
<p>The Context Database is used to persist contexts through a backend consisting of a database or data store software. Apps query the Context Database to insert and retrieve contexts. The sharing of contexts is done asynchronously as apps can query for contexts without being aware of which app performs the inserts. The software used to implement the Context Database is an implementation choice as long as it follows the basic CRUD operations required for the functioning of the contextual data sharing model. A few performance considerations such as access time and average query execution time need to be taken into account to keep the user interactions within apps running smoothly. The managing of query execution time is tackled by managing the size of the database. The Deletion Policy is responsible for handling the deletion and is an implementation choice as the actual deletion operations are affected by the design, schema and software being used.</p>
<h2 id="contextual-data-sharing-model">Contextual Data Sharing Model</h2>
<p><em>“You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete.”</em></p>
<p>– <em>Buckminster Fuller</em></p>
<h3 id="sec:introduction">Introduction</h3>
<p>The Contextual Data Sharing Model describes the various components required to create a framework that enables applications to store and share contextual information. The responsibility of each component and its relation with other components is specified in the model. Designing and implementing the components individually or separate from other components can create a disparity in the working and sharing of information. The Contextual Data Sharing Model describes the responsibilities of various components, which allows a design-level understanding of the working and limitations of each component. This allows the components to be designed and implemented in different ways as long as each component fulfills the responsibilities in the model. This allows the model to be designed and implemented on a variety of platforms.</p>
<p>Components in the model constitute the Context Definitions, which allow applications to identify contextual information, and to share it with other applications. The Context Database provides a way to persist contexts, that allows sharing of contextual information across apps. Utilizing Context Definitions and storing it in Context Database allows collection of information related to a context in a single, uniform and identifiable structure, and allows it to be stored and queried by apps independently. The module responsible for managing interactions between apps and the Context Database is the Context Manager.</p>
<p>The Contextual Data Sharing Model ties in the various components to provide contextual information to apps. The availability of such contextual information allows apps to design services that allow users to carry over tasks seamlessly across different apps.</p>
<h3 id="sec:system_model">System Model</h3>
<p>The various components of the Contextual Data Sharing Model are depicted in Fig. <a href="#fig:system_model" data-reference-type="ref" data-reference="fig:system_model">[fig:system_model]</a>. The components are separated into <em>System</em> and <em>User App</em> partitions based on their responsibility, access and usage. The Context Database and Context Definitions lie within the System partition. The Context Manager lies within the User App partition. The partitioning of components allows separation of responsibility and provides security and stabilization to the Contextual Data Sharing Model.</p>
<h4 id="sub:system_components">System Components</h4>
<p>The components in the system process are managed by the system and lie outside and separate from any user app’s process. The separation of Context Database allows control of access to information, and provides stability and security. It acts as a barrier to prevent corruption of data and malicious access from harmful apps. The separation also allows changes to the underlying components such as the Context Database without affecting the overall design of the Contextual Data Sharing Model. The changes made would be transparent to the user apps, who would continue to interact with the Context Database in a specified manner.</p>
<h5 id="subsub:context_definitions">Context Definitions</h5>
<p>The Context Definitions are used by the system to instantiate context objects. Whenever an app creates a context object, the system refers to the Context Definitions to create an object of the specific context. Since the Context Definitions represent the structure of shared contexts, they are immutable and managed by the system. This prevents any app from corrupting the definitions stored in the system.</p>
<p>The Context Definitions can be used to instantiate context objects outside of the Contextual Data Sharing Model. Developers can use the context objects in their app without the information being added to the Context Database. This allows the Context Definitions to be used freely in any way the developers see fit.</p>
<h5 id="subsub:context_database">Context Database</h5>
<p>The Context Database acts as a repository where apps can store and retrieve contexts. This allows apps to share contexts without a direct interaction between them. The Context Database comprises of the actual backend data store or database used to store the contexts, and the API used to interact with it. All access to the Context Database is through the API, which allows a limited selection of queries to be executed by the apps. The selection of queries is based on the functionality of services the Context Database offers. The actual API and queries are dependent on the implementation of the Context Database.</p>
<h4 id="sub:user_app_components">User App Components</h4>
<h5 id="subsub:context_manager">Context Manager</h5>
<p>The Context Manager acts as the middleware between an app and the Context Database. Apps that wish to interact with the Context Database can only do so through the Context Manager. This forms the access control mechanism used to restrict access to the Context Database. The Context Manager performs the necessary communications to request queries to be run in the Context Database. It is also responsible for interpreting the response from the Context Database in a format understood by the app. This involves requesting context entries from Context Database and instantiating context objects from them. The Context Manager is also responsible for performing any error checks and verifications on the correctness of a context being added to the database. More information about the Context Manager is given in Section. <a href="#sec:context_manager" data-reference-type="ref" data-reference="sec:context_manager">3.3</a></p>
<h5 id="subsub:using_context_objects">Using Context Objects</h5>
<p>An app has no ownership or control over the context object after it has been inserted in the Context Database. Other apps can update or modify contexts irrespective of whether the context was inserted by them. This allows various apps to access and update contextual information, which results in greater sharing of information keeps the information updated. A context updated by an app is instantly reflected across all other contexts that use or refer to the changed context. This allows any app to update contextual information available to it, and allows other apps to receive the updated contextual information without being aware of the update.</p>
<h3 id="sec:context_manager">Context Manager</h3>
<p>The Context Manager is a user app component, part of the user app itself. The Context Manager is embedded in the user app as a separate module or library, which cannot be changed or modified by the developers or the app itself. Each app will hold its own instance of the Context Manager at runtime or during execution. This creates a greater abstraction between the user apps and the system components, which permits more freedom in implementing the various components of the Contextual Data Sharing Model.</p>
<p>The Context Manager provides a way for apps to insert and retrieve contexts from the database without interacting with the Context Database directly. Additional features such as error checking for context objects are based on the implementation of the model and are not necessary for the working of the Contextual Data Sharing Model.</p>
<h4 id="sub:errors_generated_as_part_of_the_user_apps_process">Errors generated as part of the user apps’ process</h4>
<p>Since the Context Manager is a part of the user app, all operations performed by the Context Manager are executed as part of the user app’s process. If any fault of error is generated during an operation in the Context Manager, then the fault or error is generated as part of the user app. This keeps all faults and errors generated within the app from affecting other components, and prevents apps from crashing the Context Database. If the app tries to run some operation within the Context Manager that causes instability in the system or potentially crashes any process, then the app’s process itself will become unstable and will crash. The unstable operations run as part of the Context Manager are actually being run in the user apps process. This provides stability and security to other apps and the system from potential crashes and errors. This also allows the Context Database to continue working in case a query causes errors, as the error is generated in the process containing the Context Manager. This allows other apps to interact with the Context Database without interruptions, and allows the Context Database to continue to handle requests from other apps.</p>
<h4 id="sub:checking_queries_to_be_executed">Checking queries before execution</h4>
<p>The Context Manager acts as a mediator between the app and the Context Database. It accepts requests from the app, creates appropriate queries and sends them to the Context Database. It interprets the results of those queries and creates context objects which the app understands. For the app, the Context Manager is the sole interface to the Context Database and all inserts and requests are completed through it. This allows all operations requested by the app to be checked for errors or completeness before passing on to the Context Database.</p>
<p>For example, if an app requests an <em>Event</em> context to be added to the database, the Context Manager will first check whether all fields of the context object are properly initialized. Only then will it send the query to the Context Database to add the context object. Doing so provides additional security as incorrect requests are not sent to the Context Database but are handled by the Context Manager itself. This reduces the checks performed by the Context Database, and allows faster execution of requests. This increases the efficiency of operations run by the Context Database and allows more apps to interact with the Context Database simultaneously.</p>
<p>The Context Manager requests queries to be run on the Context Database on behalf of the app. The queries requested by Context Manager are based on a fixed subset of queries explicitly allowed to be run by user apps, and cannot be changed. If a malicious app somehow manages to make the Context Manager request execution of queries other than those specified, the request will fail as the Context Database will not execute the query. So operations and requests from the Context Manager to the Context Database are safe, and are checked before execution.</p>
<h3 id="sec:security_considerations">Security Considerations</h3>
<p>The contextual nature of information stored within the Context Database can lead to security concerns. These include handling privacy of information and preventing corruption of data. It is important to be aware that sensitive information may be stored within the Context Database and it is important to ensure that proper checks are put in place to access such information.</p>
<p>One way many smartphone operating systems (including Android and iOS) handle access to information and resources is through the use of Permissions. The app requests or declares the intention of using certain information or resource and requests access to it. The system or the user, depending on the implementation of such a model, will grant or reject access to the app if they choose to do so. This system of using permissions to explicitly declare the resources and information an app needs to work can also be used to control access to information stored in the Context Database.</p>
<p>Permissions can be utilized to restrict access to the Context Database and to the use of contexts itself. An app can provide explicit read-write permissions for each kind of context they intend to use at the time of installation of during each use of that context. The system or the user can use these permissions to be aware of the information the app is accessing and can act if the information being requested does not match the activities of the app. Separate read and write permissions can be used for apps that want to use contexts from the Context Database, but will not insert contexts. This will prevent apps from corrupting information in the Context Database under the guise of providing some service that relates to only reading of information in the database. A malicious app can still take advantage of the system by offering some service that requires the write permission, and then inserting corrupt data to the Context Database. Such apps can be better scrutinized for suspicious actions through explicit context permissions that declare what contexts the app wishes to read or write from the database. For example, a movie ticket booking app requesting access to <em>Movie</em> contexts can be considered as normal. But if the same app requests access to all <em>Event</em> contexts, then the app should be scrutinized more carefully.</p>
<h3 id="sec:use_case">Example: Apps using the Contextual Data Sharing Model</h3>
<p>In the movie ticket booking use case, the task requires the use of several apps that store the acquired information in a way that is not shared with other apps. This leads to other apps depending on the user to acquire the contextual information, which leads to duplication of information and efforts required to enter it in to the app. With the Contextual Data Sharing Model, each app designs its services on the assumption that contextual information is available to it. In cases where suitable contextual information is not available, the app has the option of asking the user to enter the required information.</p>
<p>The app responsible for generating or interpreting the contextual information stores it in the Context Database so that it can be shared with other apps. The movie ticket booking app saves the appropriate information in the form of a <em>Movie</em> context that contains the details about the movie such as title, show times, ticket and seat information and also the theater location and contacts who are attending the movie. Some of this information such as theater location and contacts may not be available at this stage, but can be filled in by other apps who have access to this information.Once the booking app has inserted the contextual information in the Context Database, other apps can access it and provide services based on the information.</p>
<p>The user is likely to perform actions related to the context, which in this case is to forward the details of the booking to other attendees, or to find a route on a map to the theater, or to access seat information once at the theater. Each app that provides one or more of these services access the contextual information of the movie context in the database to provide services that are directly related to the user’s task. This is more useful for the user as related services are offered without the user having to navigate within the app or having to enter information.</p>
<p>The Messaging app which is used to send movie details of the booking can utilize the Contextual Data Sharing Model to access the contextual information in to the <em>Movie</em> context. It can then offer to insert this information in to the message saving the user the effort of entering the information or copying it from another source. Additionally, it can allow the user the choice of selecting the fields from the <em>Movie</em> context to be inserted into the message body, and to use the <em>Contacts</em> from the context as the recipients. To make it easier for the user to retrieve contextual information, the messaging app can show the recently used or recently added contexts. Such filtering of contexts based on time is dependent on the Context Database implementation.</p>
<p>By providing information to the user in an easily usable format, the user is more likely to complete tasks in fewer steps. Additionally, the user is presented with information and services most likely required, which increases the quality of user experience and decreases the time taken to complete tasks. When the user opens a Maps application that provides navigational services, the app can retrieve a list of upcoming <em>Events</em> from the Context Database to offer a choice of locations for routes. If the user selects a route displayed within the list, the <em>Location</em> field of the corresponding <em>Event</em> is used as the destination in the navigation. This saves the user the effort of typing in the address of the <em>Event</em> and also prevents ambiguity or confusion with similar addresses and areas. Further, the user can select routes for the theater as well due to the model generalizing the <em>Movie</em> as an instance of <em>Event</em>. This reduces the effort required by the Maps developer to integrate different context types into their app.</p>
<p>Once at the theater, the user would want the ticket and seat information at various times. An app providing location-based reminders can show a notification containing this information for easier access to the user. It can use the <em>Location</em> field from the <em>Movie</em> context to trigger the reminder, and then show the ticket and seat information from the same context. This saves the user the effort of creating the reminder themselves by entering all the associated information.</p>
<p>By using specific queries that retrieve data based on some parameters, the apps can utilize contexts more efficiently. This allows apps to design more services based on the specific nature of contexts that they can request from the Context Database.</p>
<p>For example, a daily planner app that generates an agenda for the day will query the Context Database for <em>Events</em> and other related contexts that occur on a given date. This allows the app to pull in only those contexts which are useful to it at the given moment. Another example can be a restaurant app that queries the Context Database for <em>Events</em> and their location to provide recommendations in nearby areas. By filtering contexts, apps can tailor specific services based on the results of such queries.</p>
<h3 id="sec:summary">Summary</h3>
<p>The Contextual Data Sharing Model consists of three parts - the Context Definitions that provide a uniform representation of contexts, the Context Database that stores the contexts and the Context Manager that acts as a middleware between the app and the Context Database. Apps that wish to use the Contextual Data Sharing Model and interact with the Context Database can only do so through the Context Manager. All means of sharing contextual information between the apps is indirect and through the Context Database, whose purpose is to store and allow sharing of contextual information across applications.</p>
<p>The Contextual Data Sharing Model enables the collection of information related to a context in a single structure, and enables apps to provide services using contextual information available in the Context Database. This allows users to carry over tasks across different apps by sharing contextual information related to their actions.</p>
<h1 id="contextual-data-sharing-in-android">Contextual Data Sharing in Android</h1>
<h2 id="implementation">Implementation</h2>
<p><em>“Talk is cheap. Show me the code.”</em></p>
<p>– <em>Linus Torvalds</em></p>
<p>The implementation described in this thesis is a proof-of-concept meant to test and demonstrate the working and impact of the Contextual Data Sharing Model. The model was implemented on the Android platform, chosen for its openness and ease of modification. The various components were developed with technologies that are native or work well with Android.</p>
<p>The Context Definitions are modeled using Java Classes which allows context objects to be instantiated as Java objects. The Context Database uses SQLite for the backend to store contexts objects. The Context Manager is realized as a static Java class embedded in every application. Components of the model such as the Context Database and the Context Definitions are designed to facilitate porting to other platforms. Other components such as the Context Manager and the implementation of Context Definitions utilize technologies specific to the Android ecosystem and require additional effort for porting to other platforms such as iOS. The code for the implementation is hosted in a git repository at <code>https://github.com/coolharsh55/ContentProvider</code>.</p>
<h3 id="sec:choice_of_platform_and_software">Choice of Platform and Software</h3>
<h4 id="sub:platform">Platform</h4>
<p>Of the major smartphone operating systems in use today (iOS and Android), Android offers more choice and freedom of implementation due to its openness and availability of source code. The platform allows a greater degree of data sharing than iOS, which allows for easier demonstration of the Contextual Data Sharing Model.</p>
<p>The platform used in the implementation is Android version 4.4.4, also known as <em>KitKat</em>. At the time of inception of this research, this was the latest stable version of Android available. A newer version of Android, version 5.0 also known as <em>Lollipop</em> was released in November 2014. The newer version does not include any major change that affects the design or the working of the Contextual Data Sharing Model. As such, the existing implementation will work with minor adjustments on the newer platform.</p>
<h4 id="sub:context_definitions">Context Definitions</h4>
<p>Contexts can be referenced and implemented in a number of ways. The main concern of implementing Context Definitions is storing the entire contextual information in a single context object. Traditional representations of context such as RDF and OWL use a structured schema to represent contextual information and relationships. Using such formats on a smartphone has the drawback of requiring parsing every time the information is to be used. Furthermore, such formats cannot encapsulate the associated functionality that is associated with a context object. This introduces additional complexity in the design of the system and the code.</p>
<p>Data on smartphone operating systems is often serialized in formats native to the platform and code for easier management and access at a later time. The formats discussed previously are not native on smartphone platforms and will need to be converted or interpreted to native forms before use. This makes the serialization and representation of contexts difficult and introduces additional steps in the code.</p>
<p>Therefore, a context is represented using Java Classes which are native to the Android platform and are familiar to the developers of apps on Android. Using Java to represent the contexts simplifies the code as there is no need for parsing or extraction. All related functionality such as error-checks and marshaling is encapsulated into the class itself, which leads to cleaner code and better management of contexts.</p>
<p>Since Android uses a native Java runtime environment, the Java classes used to represent contexts are instantiated as Java objects. This results in better management of memory during execution and allows sharing of information across apps without conversion. The developers of apps can use data structures and code management techniques related to Java for managing contexts.</p>
<h4 id="sub:context_database">Context Database</h4>
<h5 id="subsub:local_vs_cloud">Local versus Cloud</h5>
<p>The design of the Contextual Data Sharing Model allows the Context Database to be implemented abstractly with different backends. The Context Database can be implemented as a cloud-based data store which performs operations in the cloud and returns the result back to the device. Such an implementation would have the advantage of additional features possible due to the increased storage and processing power of the cloud. The drawbacks of such an implementation would include the need to access the cloud provider on every request, the constant dependence on network connectivity for the Contextual Data Sharing Model to work and the effect of network QoS on the time required for various operations.</p>
<p>The contextual information discussed in this thesis is generated and consumed by the apps installed on a smartphone. A local database situated on the device and working as the backend for the Context Database offers the advantage of keeping all information generated, stored and consumed within the same ecosystem. It also makes it possible to use cloud offloading to offer additional functionality and resources. The database system used in this implementation is situated locally on the device.</p>
<h5 id="subsub:backend_database_software">Backend database software</h5>
<p>It is necessary to use database systems that are stable and readily available as they provide high availability across a large variety of devices. Storing hierarchical data like the context hierarchy in relational database becomes increasingly complex and restrictive as more nodes are added to the hierarchy <span class="citation" data-cites="RDBMSHierarchy"><a href="#ref-RDBMSHierarchy" role="doc-biblioref">[79]</a></span>. The increase in complexity creates difficulty in storing contexts efficiently in the database.</p>
<p>The structure and querying of contextual information is highly dependent on the type of database software used. A RDBMS restricts the flexibility to change or update the context schema without first migrating all data outside the database. In contrast to this, NoSQL database solutions <span class="citation" data-cites="NoSQL"><a href="#ref-NoSQL" role="doc-biblioref">[80]</a></span> such as graph and document databases are more suitable for storing hierarchical data. A graph database is useful for storing relationships between various contexts, which can increase the quality of contextual information stored on a device. However, the use of graph databases is restricted by the lack of availability of popular and stable products that work well on mobile devices.<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
<p>The Context Database component in the specified implementation uses SQLite version 3.7.11 <span class="citation" data-cites="SQLite"><a href="#ref-SQLite" role="doc-biblioref">[81]</a></span>, which is a popular serverless SQL database available on all major platforms. SQLite is pre-installed on all Android devices, and the version specified is found on all devices running Android 4.4.4 (Kit-Kat).</p>
<h3 id="sec:implementation_system_model">System Model for Implementation</h3>
<p>Fig. <a href="#fig:implementation_model" data-reference-type="ref" data-reference="fig:implementation_model">[fig:implementation_model]</a> shows the system model for the implementation of Contextual Data Sharing Model on Android. The system components are managed by the Android system and run under the system process. The components in the user app are run under the user app’s process.</p>
<p>The Context Definitions are represented using Java Classes, which are pre-installed to provided a uniform implementation across devices. Developers access these classes as part of an API when writing the app code. During execution, apps use the Context Definitions which are a part of the system to instantiate context objects.</p>
<p>The Context Database is managed by the system and is exposed to the apps through an API handled by Android’s Content Provider mechanism. For storing data, the Context Database uses SQLite which is pre-installed on Android. The SQLite database used is considered pre-installed and part of the system, though in practice an app was used to instantiate the Content Provider and the corresponding tables.</p>
<p>All queries from an app to the Context Database are handled through the Context Manager. The Context Manager is instantiated as a static Java class in the user app’s process, and is responsible for querying the Context Database through the Content Provider interface. It interprets the results returned from the Context Database to instantiate context objects which are then passed back to the app.</p>
<p>Every app has its own instance of the Context Manager which acts as a middleware between the app and the Context Database. Apps use the API provided by the Context Manager to insert or retrieve context entries from the Context Database. The Context Manager in turn uses the API provided by the Content Provider to communicate with the Context Database. Except for the actual database queries, all other operations such as field-checking, marshaling and error-checks are performed by Context Manager in the user app’s process. Apps are free to create and utilize context objects. The Context Manager performs the error and instantiation checks only when objects are being inserted or updated in the database.</p>
<h3 id="sec:context_definitions">Context Definitions using Java Classes</h3>
<h4 id="sub:java_class">Context Java Class</h4>
<p>Context Definitions are represented through Java classes which are then instantiated into Java Objects. Each context type is represented using its own unique Java class. Listing <a href="#lst:event_class" data-reference-type="ref" data-reference="lst:event_class">[lst:event_class]</a> represents the <em>Event</em> context using a Java class called <em>EventData</em>. Each context class is suffixed with <em>-Data</em> to prevent clashes with other classes that may have the same name. For example, Android has several classes named <em>Event</em> in different packages. For the sake of brevity, this text omits the suffix when speaking about specific Java classes. For example, the <em>Event</em> Java class actually refers to the <em>EventData</em> Java class in code. The code listings provided contain the actual class name with the suffix.</p>
<p>All context classes are defined in the package <code>msc.prototype.context</code> and are extended from a common context class called <em>Context</em>. The <em>Event</em> class shown in Listing <a href="#lst:event_class" data-reference-type="ref" data-reference="lst:event_class">[lst:event_class]</a> belongs to this package that groups it together with other context classes. The title field is a String that depicts the Event title. The date is a Date object that stores the date and time. The <em>Location</em> context is a sub-context that refers to the location of the event. The contacts are stored as an ArrayList of <em>Contact</em> contexts.</p>
<figure id="lst:event_class">
    <pre><code>package msc.prototype.context;

import android.net.Uri;
import Java.util.Date;
import android.os.Parcelable;

class EventData extends ContextData {
    String title;
    Date date;
    LocationData location;
    ArrayList&lt;ContactData&gt; contacts;
    Uri uri;
    // other methods and parameters
}</code></pre>
    <figcaption>Schema for <em>Event</em> Context</figcaption>
</figure>
<h5 id="subsub:uri_field">URI field</h5>
<p>The URI field stores links for related information about a context. A URI in Android can be used to refer to information in websites and also in apps. For <em>Event</em>, the link can point to the event website or an app that holds this information. Apps that want to handle a particular URI scheme need to register the scheme with the system. This is done by declaring the scheme in the app’s manifest. The manifest of an app acts as a declaration of the requirements and components and is used by the system during installation of the app. The system reads the scheme information declared in the manifest during installation of the app and associates that particular scheme with the app. For example, an app registers the scheme <em>http://</em> which is used to browse webpages. Anytime the user clicks on a link that starts with the specified scheme <em>http://</em> the system will show a list of all apps that handle the particular link. In case of the <em>Event’s</em> URI field, the link is opened by the system with appropriate apps that can handle the scheme.</p>
<p>Apps can store links to information or services offered by them through this URI field. A restaurant booking app can store a link that points to the booking activity within that app. Clicking on this link will take the user directly to the activity in the booking app where they can manage the booking or use additional services offered by the app.</p>
<p>The URI links can be opened or triggered inside any app as the system handles all links and opens the appropriate app. This allows apps to display links to information and services belonging to other apps. This allows related services to be displayed which helps users to perform tasks related to the context without explicitly switching apps.</p>
<h4 id="sub:abstract_context_class">Abstract Context class</h4>
<p>The abstract <em>Context</em> which acts as the ancestor of all contexts is realized using the <em>ContextData</em> Java class. Listing <a href="#lst:context_class" data-reference-type="ref" data-reference="lst:context_class">[lst:context_class]</a> shows the <em>Context</em> class and its associated fields and methods.</p>
<figure>
    <pre><code>package msc.prototype.context;

import android.os.Parcelable;

class ContextData implements Parcelable {
    private long _id;
    public final long get_id(SystemToken token) {
        return _id;
    }
    public final void set_id(SystemToken token, long _id) {
        this._id = _id;
    }
    public abstract String shortDescribe(); // short description
    public abstract String longDescribe();  // long description
    public abstract boolean checkFields();  // perform field checking
}</code></pre>
    <figcaption>Schema for <em>Event</em> Context</figcaption>
</figure>
<p>It contains an <em>id</em> field of type long (long integer, holds larger values) that represents the particular <em>id</em> of that context object in the Context Database. To retrieve or set this <em>id</em>, the get/set methods require an object of type <em>SystemToken</em>, which can only be generated by the system. This ensures that only the system has access to the <em>id</em> field and that apps cannot change or modify it. By declaring the <em>id</em> field in the <em>Context</em> class, all contexts that extend it inherit the <em>id</em> field as a property of that class.</p>
<p>The abstract methods <em>shortDescribe</em> and <em>longDescribe</em> are used to retrieve information about the context in a String format. This can be used by apps to display information about contexts in an easier way than manually accessing the various fields. For example, the <em>shortDescribe</em> method of the <em>Event</em> class returns information about the title and date/time of the event. The <em>longDescribe</em> method returns more information including the title, date/time, location, contacts and a URI link. These methods can be useful when an app is dealing with different kinds of contexts and needs to display information about them without having to access individual fields within the context objects. For example, a calendar app can simply call <em>shortDescirbe</em> on context objects to get their descriptions to be displayed in an agenda view.</p>
<p>The abstract method <em>checkFields</em> is used to perform field-checking over the context object. The method checks if the fields are properly initialized and if the information they contain can be safely added to the Context Database. Apps can use this information to check information in a context object for correctness.</p>
<p>The <em>ContextData</em> class implements the <em>Parcelable</em> <span class="citation" data-cites="Parcelable"><a href="#ref-Parcelable" role="doc-biblioref">[82]</a></span> interface which is the preferred method for marshaling data across processes in Android.<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> The Parcelable interface and its associated methods are inherited by all context classes by extending the <em>Context</em> class. This allows all context objects to be efficiently marshaled across processes through the Parcelable implementation provided by the Android system.</p>
<p>The abstract methods declared in the <em>Context</em> class need to be implemented in every concrete context class that extends it. Since the methods are context-specific, every context type will have a different implementation of the methods based on the functionality and fields contained within that context class.</p>
<h4 id="sub:extending_contexts">Extending Contexts</h4>
<p>Extending contexts is achieved through Java’s object-oriented concepts <span class="citation" data-cites="JavaOOP"><a href="#ref-JavaOOP" role="doc-biblioref">[83]</a></span> which allow one class to extend another class. Context classes extend existing classes and behavior by extending the respective Java class. For example, Listing <a href="#lst:movie_class" data-reference-type="ref" data-reference="lst:movie_class">[lst:movie_class]</a> shows the <em>Movie</em> class. The <em>Movie</em> class extends the <em>Event</em> class, which corresponds to the <em>Movie</em> context extending the <em>Event</em> context. The fields title, date/time, location, contacts and URI are inherited by <em>Movie</em> from the <em>Event</em> class. The <em>Movie</em> class declares the fields for ticket and seat information which are not present in the <em>Event</em> class.</p>
<figure id="lst:movie_class">
    <pre><code>package msc.prototype.context;

import android.net.Uri;
import Java.util.Date;
import android.os.Parcelable;

class MovieData extends EventData {
    String ticket;
    Stirng seats;
    // other methods and parameters
}</code></pre>
    <figcaption>Schema for \textit{Movie} Context extended from \textit{Event} Context</figcaption>
</figure>
<p>The hierarchical structure of contexts is similar to Java’s object model, where each class has a common ancestor called <em>Object</em>. Every class can only extend one other class which keeps the class organization simple and prevents the problems associated with multiple inheritance. If a use case requires the use of multiple inheritance in relation to contexts, one possible solution is to extend one parent and to embed the other parents as sub-contexts.</p>
<h4 id="sub:generalization_of_contexts">Generalization of Contexts</h4>
<p>Generalization of an object to its parent class means interpreting an object of the derived class as if it were an object of the parent class. This increases the re-usability of code as the same code can handle multiple types of objects based on how they are derived from a particular context. This allows creation of apps that target contexts situated higher in the hierarchy and work with all contexts directly below it. In terms of implementation using Java classes, this allows apps to include code written to work with one context, which will work with all contexts that have extended the specified context. Therefore, functions written for <em>Event</em> objects will also work with <em>Movie</em> objects as the system generalizes the <em>Movie</em> object into an instance of the <em>Event</em> object. In Java terminology, this is called <em>type casting</em>. Here the <em>Movie</em> object is cast as an <em>Event</em> object by the system.</p>
<p>Listing <a href="#lst:generalization_context" data-reference-type="ref" data-reference="lst:generalization_context">[lst:generalization_context]</a> shows a function <em>handleEventContext</em> that accepts <em>Event</em> objects. Another function <code>foo</code> calls <code>handleEventContext</code> and passes it a <em>Movie</em> object. The system automatically casts the <em>Movie</em> object to an <em>Event</em> object before passing it to the <code>handleEventContext</code> function.</p>
<figure id="lst:generalization_context">
    <pre><code>void handleEventContext(EventData event) {
    // do something with event
}

void foo() {
    // movie context object
    MovieData movie = new MovieData();
    // pass handleEventContext a movie object
    handleEventContext(movie);
}</code></pre>
<figcaption>Schema for \textit{Event} Context</figcaption>
</figure>
<p>Apps such as Calendar that primarily handle <em>Event</em> contexts can provide the same services for all contexts that extend the <em>Event</em> class. This means contexts such as <em>Movie, Lunch, Meeting,</em> and <em>Concert</em> that extend the <em>Event</em> class are automatically converted to <em>Event</em> context objects before being used by the Calendar app. This allows the Calendar app to handle all types of events while writing minimal code and focusing on the features provided rather than putting in effort to support more context types.</p>
<h4 id="sub:embedding_contexts">Embedding Contexts</h4>
<p>Embedding contexts is achieved by including the sub-context as an object reference inside the context class. This allows the embedded context to be referenced as a field. Listing <a href="#lst:location_class" data-reference-type="ref" data-reference="lst:location_class">[lst:location_class]</a> shows the <em>Location</em> class which is embedded in the <em>Event</em> class.</p>
<figure id="lst:location_class">
    <pre><code>package msc.prototype.context;

class LocationData extends EventData {
    protected Stirng placename;
    protected double xpos;
    protected double ypos;
    // other methods and parameters
}</code></pre>
    <figcaption>Schema for <em>Event</em> Context</figcaption>
</figure>
<p>The <em>Location</em> class contains the fields and methods necessary to represent a <em>Location</em> context. By embedding the context in the <em>Event</em> context, every <em>Event</em> object will contain a reference to a <em>Location</em> object. This allows a context object to contain references to associated information even if the information itself may not be stored collectively with that context. The <em>Location</em> reference can be used to modify the location information associated with the <em>Event</em>, or to point it to another existing <em>Location</em> context. Listing <a href="#lst:location_uses" data-reference-type="ref" data-reference="lst:location_uses">[lst:location_uses]</a> shows how the <em>Location</em> reference can be used to access the location information, and how different locations can be associated with an <em>Event</em>.</p>
<figure id="lst:location_uses">
    <pre><code>void useLocation{EventData event} {
    // gets location&#039;s / place name
    doSomething(event.getLocation().getPlaceName());
}

void updateLocation(EventData event) {
    // sets event&#039;s location to current location
    LocationData location = getCurrentLocation();
    event.setLocation(location);
}</code></pre>
    <figcaption>Using <em>Location</em> context</figcaption>
</figure>
<h3 id="sec:context_database">Context Database using SQLite</h3>
<h4 id="sub:sqlite_as_backend">Initializing the database</h4>
<p>The implementation for the Context Database uses SQLite version 3.7.11 as the backend for storing the contextual information. This version of SQLite is pre-installed on all Android v4.4.4 KitKat devices.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></p>
<p>The creation and initialization of the SQLite database was done through a separate app. The app creates a database called <em>Contexts.db</em> and initializes the necessary tables required for creating the Context Database. The Content Provider interface used to interact with the SQLite backend is also initialized through this app. The Content Provider is utilized by the Context Manager to interact with the Context Database through a set of standard API’s.</p>
<h4 id="sub:context_entries_and_tables">Context entries and tables</h4>
<p>Every context type has its own distinct table in the SQLite database. Each field in the Context Definition schema is stored as a separate column in the table. The <em>id</em> field defined in the abstract <em>Context</em> acts as the primary key in all context tables. This ensures that all context entries stored in a table are unique with respect to the contextual information they represent. The table schema for the <em>Location</em> context is shown in Listing <a href="#lst:table_location" data-reference-type="ref" data-reference="lst:table_location">[lst:table_location]</a>.</p>
<figure id="lst:table_location">
    <pre><code>create table if not exists LOCATION(
 _id INTEGER PRIMARY KEY AUTOINCREMENT,
 place TEXT NOT NULL,
 xpos REAL NOT NULL,
 ypos REAL NOT NULL
);</code></pre>
    <figcaption>Table schema for Location context</figcaption>
    </figure>
<p>Where a context extends another context, only the fields declared in the extended context are stored in extended context’s table. The fields inherited from the parent context are stored in the parent context’s table. For example, Listing <a href="#lst:table_event" data-reference-type="ref" data-reference="lst:table_event">[lst:table_event]</a> shows the table schema for the <em>Event</em> context and Listing <a href="#lst:table_movie" data-reference-type="ref" data-reference="lst:table_movie">[lst:table_movie]</a> shows the table schema for the <em>Movie</em> context. The table for <em>Movie</em> contains a reference to an entry in the <em>Event</em> context where the inherited fields are stored. Both entries share the same id belonging to the <em>Movie</em> context added to the database. While inserting a <em>Movie</em> context, it is ensured that there is no clash or overlap with an existing entry in the <em>Event</em> table.</p>
<figure>
    <pre id="lst:table_event"><code>create table if not exists EVENT(
 _id INTEGER PRIMARY KEY AUTOINCREMENT,
 title TEXT NOT NULL,
 date INTEGER NOT NULL,
 uri TEXT NOT NULL);
);</code></pre>
<figcaption>Table schema for <em>Event</em> context</figcaption>
<pre id="lst:table_movie"><code>create table if not exists MOVIE(
 _id INTEGER PRIMARY KEY AUTOINCREMENT,
 ticketID TEXT NOT NULL,
 seats TEXT NOT NULL,
 FOREIGN KEY(_id) REFERENCES EVENT(_id)
);</code></pre>
    <figcaption>Table schema for Movie context</figcaption>
    </figure>
<p>The separation of fields into different tables allows separate access to contextual information. When an app requests contextual information related to <em>Events</em>, only the fields in the <em>Event</em> table are returned. Since the table for <em>Event</em> also contains entries from all contexts that have been extended from the <em>Event</em> context, all the contextual information related to events is accessed from a single table. Whenever an app requests information about <em>Movie</em> contexts, the entries from the <em>Movie</em> table are matched with their corresponding entries from the <em>Event</em> table before being returned. This allows efficient use of joins and multiple queries as a join is performed only when returning extended contexts, whose entries in the table are always less than those for the parent context.<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<p>Whenever a context embeds another context, this relation is stored in a separate table unique to the relation between the two contexts. For example, the relation between an <em>Event</em> entry and a <em>Location</em> entry is stored in a separate table whose schema is shown in Listing <a href="#lst:table_eventxlocation" data-reference-type="ref" data-reference="lst:table_eventxlocation">[lst:table_eventxlocation]</a>. Each entry in this table depicts a relation between an <em>Event</em> entry and a <em>Location</em> entry.</p>
<figure id="lst:table_eventxlocation">
    <pre><code>create table if not exists EventxLocation(
 e_id INTEGER, l_id INTEGER,
 FOREIGN KEY(e_id) REFERENCES EVENT(_id),
 FOREIGN KEY(l_id) REFERENCES LOCATION(_id)
);</code></pre>
    <figcaption>Table schema for EventxLocation that stores the reference of Location objects within Events</figcaption>
    </figure>
<h4 id="sub:handling_duplicates_in_database">Handling Duplicates in Database</h4>
<p>Contextual information should not be duplicated in the Context Database. Since context entries represent contextual information, it is necessary to ensure that there is only one instance of a context in the Context Database. Two context entries are said to be duplicates if the contextual information they convey is the same.<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> The criteria for deciding whether two contexts are duplicates depends on the fields in the context, and is different for every context type. For example, when considering two <em>Event</em> contexts, if both entries have some fields that are the same, they may not necessarily be duplicates. But if a combination of multiple fields such as title, date/time and location are the same, the context can be considered to represent duplicate information.</p>
<p>Every time a context entry is to be inserted, it is first checked if it is a duplicate of an existing context in the Context Database. If no duplicates are found, the context entry is successfully inserted and given a unique <em>id</em>. If a duplicate is found, the Contextual Data Sharing Model can work with the following two options -</p>
<ol>
<li><p><em>Refuse the insert</em>: The Context Database refuses the insert operation and the context entry is not added to the database. A <em>duplicate context entry</em> error message is sent to the corresponding Context Manager along with the <em>id</em> of the original context entry in the Context Database. This option forces the Context Manager to explicitly query the Context Database for the original context and substitute the duplicate context with the original context’s <em>id</em>. In effect, it discards the duplicate context, and returns the original context.</p></li>
<li><p><em>Accept the insert and return the original id</em>: The Context Database accepts the insert operation but does not add the duplicate entry to the database. It returns the <em>id</em> field of the original context stored in the database as the <em>id</em> of the inserted entry. The Context Manager receives an <em>insert successful</em> message and sets the <em>id</em> of the inserted context object with the <em>id</em> of the original context object in database. In this option, the Context Manager is not aware that the insert option was related to a duplicate in the database, and considers the context entry to be successfully inserted in the database.</p></li>
</ol>
<p>In both cases, there can be loss of contextual information in the fields not being used to check for duplicates between two context entries. If these fields are ignored or overwritten, it results in an unwanted change in contextual information. For example, an <em>Event</em> entry being added to the database identified as being a duplicate of an existing entry. This means that the title, date/time and location field match an existing entry in the database. The other information in the context entry such as the URI field may not be checked at all. In this case, if the <em>id</em> of the context entry in the database is returned, it will create a discrepancy in the representation of contextual information in context objects with the same id. Some instances of this context will have the URI field from the Context Database, and others may have a different URI field. This is undesirable when dealing with contextual information. If this context is again saved to the Context Database, the URI field will be overwritten with the new information. This can lead to an accidental loss of contextual information.</p>
<p>To prevent such accidental loss of information and overwriting, duplicate context entries with other differing fields should be handled through an <em>update</em> operation. The Context Manager is made aware that a duplicate exists in the database with some differing fields and has the option of discarding the differences and updating the information in the database or accepting the differences and changing the information in the context being added to the database. This can still lead to loss of information and overwriting, but the Context Manager and the app will be aware of the exact contextual information being added to the database. This approach also prevents discrepancies in context objects with the same id since all information contained within such objects will match with the information stored in the Context Database.</p>
<h4 id="sub:deletion_policy">Deletion Policy</h4>
<p>The deletion policy dictates the deletion of contexts in order to keep the performance of queries within acceptable limits. The size of database <span class="math inline"><em>t</em></span> for which the deletion policy is triggered is highly dependent on the specific device configuration and usage of the Context Database. The impact of a table’s size on the execution of queries is discussed in the Metrics and Performance chapter.</p>
<p>For the deletion policy we considered using paging algorithms <span class="citation" data-cites="PagingAlgo"><a href="#ref-PagingAlgo" role="doc-biblioref">[84, p. 288]</a></span> such as First-in First-out (FIFO), Least frequently used (LFU) and Least recently used (LRU) to decide which contexts are to be deleted. Using LFU and LRU requires storing a timestamp every time a context entry is accessed in order to determine its frequency of use. This requires a write to the database every time a context entry is read, which is unfeasible when using SQLite as it severely affects the speed of read operations.<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> Therefore, the implementation uses FIFO to select contexts for deletion since using it does not require storing timestamps on read operations.</p>
<p>FIFO orders entries based on the time when they were added to the database. This can be implemented by storing a timestamp with every entry inserted to the database. The timestamp is updated whenever the entry is updated to denote the change in information. In FIFO, the first <span class="math inline"><em>n</em></span> entries are selected for deletion based on their timestamps. The value of <span class="math inline"><em>n</em></span> is selected so as to satisfy the condition <span class="math inline">(0 &lt; <em>n</em> &lt; <em>t</em>)</span>.</p>
<p>When the value of <span class="math inline"><em>n</em></span> is small, the value of <span class="math inline">(<em>t</em> − <em>n</em>)</span> is comparable to the value of <span class="math inline"><em>t</em></span>. This causes the database size to grow to the threshold size sooner and causes degradation of performance as the deletion policy is triggered more often. If the value of <span class="math inline"><em>n</em></span> is large, the value of <span class="math inline">(<em>t</em> − <em>n</em>)</span> is comparably smaller than <span class="math inline"><em>t</em></span>, and the database size reaches threshold size more slowly. The deletion policy is triggered after significant time intervals, and prevents the degradation of performance over time. However, this also deletes more contexts in a single operation and may delete contextual information that could have been useful.</p>
<p>The value of <span class="math inline"><em>n</em></span> is calculated based on a combination of conditions such as device configuration, frequency of queries and operational costs involved.<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> In this implementation, the value of <span class="math inline"><em>n</em></span> is within the range <span class="math inline">(1000 &lt; <em>n</em> &lt; 5000)</span> depending on the context table under consideration.<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a></p>
<p>Along with FIFO, context entries for some context types can also be selected based on the relevance of their contextual information. For example, some context types such as <em>Event</em> are based on a specific date/time, which is more relevant than the insertion timestamp used in FIFO. Such context types are deleted based on relevance using the ordering of information present in the context table.</p>
<p>If a context entry being deleted is an embedded entry, then it is only deleted when all of its parent context entries are also marked for deletion. If a context entry being deleted is an extended entry, or contains a relation to an extended entry, then it is ensured that all related fields in different tables are also deleted. This ensures that useful data is not deleted in the case of embedded entries, and that all related data is removed together in the case of extended entries.</p>
<h3 id="sec:implementation_context_manager">Context Manager as a Static Java Class</h3>
<p>The Context Manager is instantiated as a static Java class in the user app’s process, and is responsible for all interactions between the app and the Context Database. It interacts with the Content Provider interface to request queries from the Context Database and interprets the response in a format understood by apps. It also performs operations such as error-checks and marshaling on context objects. All operations performed by the Context Manager are executed in the user app’s process.</p>
<p>Listing <a href="#lst:context_manager" data-reference-type="ref" data-reference="lst:context_manager">[lst:context_manager]</a> shows the implementation of the Context Manager using a static Java class called <em>ContextManager</em> that refers to the Content Provider of the Context Database using the URI <code>content://msc.prototype.contextprovider.cp/</code> that refers to the Content Provider used to access the Context Database. The application’s Content Resolver is used to resolve the URI to the Content Provider and to receive responses within the the app. When inserting or updating a context object, the Context Manager checks if the object has its <em>id</em> field set, which indicates that the object exists in the Context Database. It also performs checks for errors and field-completeness and proceeds only if no errors are found. When an app requests context objects from the Context Database, the Context Manager forms the appropriate query and sends the request to the Content Provider. Upon receiving results, it creates the corresponding context objects before returning them to the app.</p>
<figure id="lst:context_manager">
    <pre><code>package msc.prototype.context;

public class ContextManager {
    static final String uri_Event = &quot;Event&quot;;
    static final String uri_authority =
        &quot;content://msc.prototype.contextprovider.cp/&quot;;

    public static int insert(ContentResolver resolver, EventData event) {
        Uri uri = Uri.parse(uri_authority + uri_Event);
        ContentValues values = new ContentValues();
        // insert all event fields into ContentValues
        values.put(&quot;eventtitle&quot;, event.getEventname());
        . . .
        // check if event already has an id
        // check if event&#039;s subcontexts have an id
        . . .
        // perform error-checks on event
        . . .
        // insert event to Context Database
        Uri response = resolver.insert(uri, values);
        // parse the response and set event&#039;s id
        . . .
        return 0;
    }

    public static ArrayList&lt;EventData&gt; getEvents(ContentResolver resolver) {
        Uri uri = Uri.parse(uri_authority + uri_Event);
        Cursor result = resolver.query(uri, null, null, null, null);
        ArrayList&lt;EventData&gt; events = new ArrayList&lt;&gt;(result.getCount());
        result.moveToFirst();
        // initialize event objects from result and add to events
        . . .
        events.add(event);
        result.close();
        return events;
    }
}</code></pre>
    <figcaption>Implementation of Context Manager as a Static Java Class</figcaption>
</figure>
<p>The objects created by the Context Manager are tied to the app that holds the instance of the Context Manager. The objects are instantiated in the apps’ data space and their lifetime is tied to the apps’ lifetime.<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> Whenever the system performs garbage collection, the context objects are automatically cleaned without requiring any form of memory management. Due to the restrictions placed by sandboxing, each app can access only its own data, and therefore only those context objects that are created in its data space.</p>
<h3 id="sec:usage_by_apps">Usage by Apps</h3>
<h4 id="sub:using_context_classes_through_a_library">Providing Context Classes in an Android Library</h4>
<p>Apps use the Contextual Data Sharing Model by including a library situated in a file called <code>ContextManager.aar</code>,ßßß an Android Archive module<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> which should be copied to an app’s library (<em>lib</em>) directory along with adding a reference to the app’s Gradle build.<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> Listing <a href="#lst:gradle_build" data-reference-type="ref" data-reference="lst:gradle_build">[lst:gradle_build]</a> shows the gradle build for an app using the Contextual Data Sharing Model by including the library file as an external library. The library contains the context classes, the Context Manager class and implementation of other APIs required for using the model. The context classes and the Context Manager class are packaged and used as a external library since these classes cannot be installed at a system level on the Android device.<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> The context classes cannot be installed on an unmodified Android distribution due to the security model of the platform. In order to demonstrate the Contextual Data Sharing Model, the apps gain access to the context classes through the integrated library which contains a copy of these classes.</p>
<figure id="lst:gradle_build">
    <pre><code>dependencies {
    compile(name:'ContextProvider', ext:'aar')
}</code></pre>
    <figcaption>Adding the library as a module in Gradle</figcaption>
    </figure>
<h4 id="sub:change_vs_new">The <em>Change vs. New</em> Policy </h4>
<p>Apps that insert context objects in the Context Database must be aware of instances where an existing context is accidentally updated instead of adding a new context to the Context Database. The <em>Change vs. New</em> policy informs developers of the correct use cases for insert and update operations in order to prevent unwanted changes to the contextual information present in the Context Database.</p>
<p>The following example demonstrates the basis and need for this policy: an app updates the co-ordinates within a <em>Location</em> context associated with an existing <em>Event</em> to reflect a change in the <em>Event’s</em> location. Other contexts that are associated with or use this particular <em>Location</em> as a sub-context or through a reference will now point to the updated co-ordinates. As a consequqnce, any other <em>Event</em> contexts that share this textit<span>Location</span> context will have their venue (location) changed. This results in a change in the contextual information and introduces incorrect information and affects the integrity of information utilized.</p>
<p>To prevent this, it is necessary for developers to be aware of the <em>Change vs. New</em> policy which dictates that <em>if a context is being updated, refined or corrected in some form, only then may the information within the context be changed or updated. In all other cases where information is being modified to change the intended meaning of the context, a new context object should be created and added to the database.</em> Applying this policy to the example described above tells the developer to create a new <em>Location</em> object since the intended meaning of the context is being changed.<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> Following this policy is left to the discretion of the developers since it is impossible to check programmatically whether a change made to any context is incorrect or violates the principle behind the <em>Change vs. New</em> policy.</p>
<h3 id="sec:demonstration_of_apps_using_the_contextual_data_sharing_model">Demonstration of Apps using the Contextual Data Sharing Model</h3>
<p>Here we demonstrate the use of the Contextual Data Sharing Model in the movie ticket booking use case. Fig. <a href="#fig:app_moviebooking" data-reference-type="ref" data-reference="fig:app_moviebooking">[fig:app_moviebooking]</a> shows a screenshot of the app that allows users to book movie tickets. Users select the movie they wish to watch along with the preferred date/time, theater and number of seats. The app then generates a ticket with the selected details and a ticket ID and seat information. It stores this information in a <em>Movie</em> context object along with a link to the movie’s IMDb page. The app then inserts the information in the Context Database by calling the <em>insert</em> method of its Context Manager. A sample of the code used for performing the above steps in a movie ticket booking app is provided in Listing <a href="#lst:app_movieticketbooking" data-reference-type="ref" data-reference="lst:app_movieticketbooking">[lst:app_movieticketbooking]</a>.</p>
<figure id="lst:app_movieticketbooking">
    <pre><code>// create context object with movie information
MovieData movie = new MovieData(
    moviename,date,loc,contactData,uri,ticket,seats);
// insert context object in Context Database through Context Manager
if(ContextManager.insert(getContentResolver(), movie) != 0) {
    Toast.makeText(getApplicationContext(),
        &quot;ERROR INSERTING MOVIE CONTEXT&quot;,Toast.LENGTH_LONG).show();
} </code></pre>
    <figcaption>Movie ticket booking app</figcaption>
</figure>
<p>The apps used in the demonstration were created with distinct packages and developer signatures so as to prevent any implicit data sharing between them. This ensured that each app was unaware of the identities and existence of the other apps and acted in isolation. All apps interacted with the Context Database through the Context Manager bundled within the app.</p>
<p>A calendar app that retrieves <em>Event</em> contexts from the Context Database will also receive the saved movie information along with the other events. The app will interpret the movie information as an <em>Event</em> context and would have access to all of the fields within the <em>Movie</em> context which are inherited from <em>Event</em>. This allows the app to change contextual information such as date/time and contacts associated with the movie context through user input. The calendar will provide features such as notifications and reminders for the movie similar to other event contexts. This will save the user the effort of entering the information and setting up reminders, as the app retrieves the needed information from the Context Database.</p>
<p>The messaging app shown in Fig. <a href="#fig:app_messaging" data-reference-type="ref" data-reference="fig:app_messaging">[fig:app_messaging]</a> allows users to insert contextual information in the message body. It provides users the option to select a context entry, which is retrieved from the Context Database. The app then allows users to select fields from the context which are then inserted in the message body. The app also provides the options of using the <em>Contacts</em> from a context object to populate the recipients field of the message. Using a messaging app that allows users to select contextual information saves users the trouble of finding and entering the information. It also helps them complete common tasks such as sending movie details to all attending contacts with a few clicks within the app.</p>
<p>The maps app shown in Fig. <a href="#fig:app_maps" data-reference-type="ref" data-reference="fig:app_maps">[fig:app_maps]</a> displays a list of upcoming events retrieved from the Context Database upon opening the app. Users select an entry by clicking on it, which tells the app to use the location field of the selected <em>Event</em> context as the destination for providing navigational features. Alternatively, users can enter the address in the input bar provided at the top to set the destination themselves. The maps app provides smarter navigational features by offering the user a list of destinations they are most likely to use. In the movie ticket booking use case, the app shows an entry for the movie in the list of events. This list is shown right after the user opens the app, which saves the effort of entering the address or selecting a location in the app in order to navigate to the theater.</p>
<p>The reminder app provides notifications based on the context entries stored in the Context Database. It retrieves the <em>Movie</em> context and sets a reminder triggered by the theater’s location. Once at the theater, the app shows this notification as seen in Fig. <a href="#fig:app_notif" data-reference-type="ref" data-reference="fig:app_notif">1.4</a> that displays the ticket and seat information to the user. The user does not have to open any app or search through notes and messages to access the ticket and seat information since it is easily accessible as a notification. To create such contextual reminders, the user does not have to explicitly enter the information required to create reminders since the app retrieves it from the Context Database.</p>
<figure>
<img src="img/002-app_moviebooking.png" id="fig:app_notif" alt="Reminders app" /><figcaption aria-hidden="true">Reminders app</figcaption>
</figure>
<figure>
<img src="img/002-app_messaging.png" id="fig:app_notif" alt="Reminders app" /><figcaption aria-hidden="true">Reminders app</figcaption>
</figure>
<figure>
<img src="img/002-app_maps.png" id="fig:app_notif" alt="Reminders app" /><figcaption aria-hidden="true">Reminders app</figcaption>
</figure>
<figure>
<img src="img/002-app_notif.png" id="fig:app_notif" alt="Reminders app" /><figcaption aria-hidden="true">Reminders app</figcaption>
</figure>
<p>The flow of information and the user interactions can be seen in Fig. <a href="#fig:user_interactions" data-reference-type="ref" data-reference="fig:user_interactions">[fig:user_interactions]</a>, which depicts how the apps use the Contextual Data Sharing Model to create contextually aware services for the user.</p>
<h3 id="sec:permissions_and_security">Permissions and Security</h3>
<p>Android is a privilege-separated operating system <span class="citation" data-cites="android_permissions"><a href="#ref-android_permissions" role="doc-biblioref">[85]</a></span>, in which each application runs with a distinct system identity based on the concepts of Linux user ID and group ID. Parts of the system are separated into distinct identities, which isolates applications from each other and from the system. This forms the basis of the sandboxing model. Additional finer-grained security features are provided through a ‘permission’ mechanism that enforces restrictions on the specific operations that a particular process (app) can perform, and per-URI permissions for granting ad-hoc access to specific pieces of data.</p>
<p>Android’s native implementation of permissions can be utilized to control access to contextual information in the Context Database. This requires creating new permissions that specify the context types the app wishes to use and the operations to be performed on it. The permissions required by the app to use contexts can be declared in the apps’s manifest in a manner similar to existing permissions in Android.</p>
<p>Listing <a href="#lst:permission_manifest" data-reference-type="ref" data-reference="lst:permission_manifest">[lst:permission_manifest]</a> shows an example of how permissions can be used to declare the use of contexts by an app through its manifest. Apps must declare Read/Write permissions for the context types they wish to use. If a context contains sub-contexts in its definition, then the system can automatically grant the related permissions for using the sub-contexts, or force the developer to explicitly specify those permissions in the manifest. The choice is based on the implementation of permissions enabling the developer to select either of the two courses. It is recommended to specify all the required permissions explicitly in the manifest since this is the approach followed by the existing implementation of permissions on Android.</p>
<figure id="lst:permission_manifest">
    <pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.android.demo&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot; &gt;

    &lt;uses-permission android:name=&quot;msc.prototype.context.EVENT.READ&quot;/&gt;
    &lt;uses-permission android:name=&quot;msc.prototype.context.EVENT.WRITE&quot;/&gt;

    &lt;!-- related permissions
        msc.prototype.context.LOCATION.READ
        msc.prototype.context.LOCATION.WRITE
        msc.prototype.context.CONTACT.READ
        msc.prototype.context.CONTACT.WRITE --&gt;
&lt;/manifest&gt;</code></pre>
    <figcaption>Context permissions in the app manifest</figcaption>
    </figure>
<p>The use of permissions allows identification of what contexts an app is using. This can be used to analyze the amount of contextual information being used by the apps, which is helpful to recognize apps that steal information. The permissions are also necessary to prevent malicious access by apps, which can corrupt information in the Context Database. The permissions denote the use of information requested by the app. This information can be shown while installing the app to get an informed consent from the users.</p>
<h3 id="sec:impl_summary">Summary</h3>
<p>The examples and the demonstrations of the use cases show how contextual sharing of information is achieved by sharing information through the Context Database. The apps used the contextual information stored in the Context Database to provide contextual services, which allow the user to enter significantly less information in various apps as the necessary information was retrieved from the Context Database. This resulted in the users getting easier access to required features and allowed them to complete their tasks faster. The use of Context Database prevents the duplication of effort and information by storing data in a common and accessible way. The demonstration validates the usefulness of the Contextual Data Sharing Model.</p>
<h2 id="performance-evaluation">Performance Evaluation</h2>
<p><em>“Beware of bugs in the code; I have only proved it correct, not tried it.”</em></p>
<p>– <em>Donald Knuth</em></p>
<h3 id="sec:motivation">Motivation</h3>
<p>The Contextual Data Sharing Model allows apps to retrieve, store and share contextual information by using the Context Manager to interact with the Context Database. Apps can use the contextual information to fill the UI elements shown to the user for interacting with the app, which creates a relation between the Contextual Data Sharing Model and the app’s user experience.<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a> Therefore, the performance of the Contextual Data Sharing Model and its individual components have an impact on the performance of apps using the model, and by extension on the user experience when using such apps. This chapter provides comparisons, performance tests and experiments that are used as a proof-of-concept demonstration to gauge the feasibility of the Contextual Data Sharing Model and decide operating parameters that affect the performance and user experience of apps.</p>
<h3 id="sec:testing_parameters">Testing Parameters</h3>
<p>To test the efficiency of the model, the prior movie ticket booking use case was compared in terms of duplication of information and user effort. The performance of the Contextual Data Sharing Model consists of the performance of individual components such as the Context Database and Context Manager. Some operations in the performance tests such as IPC and marshaling that lie outside the Contextual Data Sharing Model are handled by the Android system.</p>
<p>Performance is primarily based on the time taken to execute the various operations, where the time for each operation is broken down to reflect individual times for the different components. The time taken by the Context Database consists of the time required to receive and parse a query, the time required to execute the query and the time required to create appropriate responses. The time taken by the Context Manager consists of the time required to create the appropriate query, the time required to send it to Context Database for resolution and the time required to interpret the received response and convert it into context objects. Supplementing these operations is the IPC mechanism handled by the Android system which manages the sharing of data between the Context Database and the Context Manager.</p>
<p>All tests were performed on the <em>Event</em> table that was populated with random entries at the time of database initialization.<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> The corresponding sub-contexts <em>Location</em> and <em>Contacts</em> were also randomly populated.</p>
<p>Since the tests are based on the execution of queries and the interpretation of results, the number of entries (records) in the Context Database have a significant impact on the time required to complete each operation. Each tests was run multiple times (<em>n=100</em>) and for different number of records <em>(100, 500, 1000, 5000, 10000, 50000, 100000)</em> in the <em>Event</em> table, with only those queries that successfully completed execution being considered for evaluation.</p>
<p>The time taken to execute a query is depicted by <span class="math inline"><em>t</em></span>, with <span class="math inline"><em>t</em><sub><em>m</em><em>i</em><em>n</em></sub></span> depicting the minimum value, <span class="math inline"><em>t</em><sub><em>m</em><em>a</em><em>x</em></sub></span> depicting the maximum value, <span class="math inline"><em>t</em><sub><em>a</em><em>v</em><em>g</em></sub></span> depicting the average, and <span class="math inline"><em>t</em><sub><em>s</em><em>t</em><em>d</em><em>e</em><em>v</em></sub></span> depicting the standard deviation.</p>
<h3 id="sec:environment">Operating Environment</h3>
<p>The experiments were carried out on a <em>Nexus 7</em> running Android v4.4.4 Kit-Kat.<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> No other software or apps were installed and the stock ROM was not modified, rooted or supplemented in any way. The device battery was kept at near full charge, and the connectivity options (Wi-Fi, Bluetooth, NFC) were disconnected to prevent unwanted interferences in the tests. The performance metric values were obtained through timestamps from logging at strategic points in the code. The logs and process stats were gathered using <em>adb</em> and logcat<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> interfaces.</p>
<h3 id="sec:user_impact_comparison">User Experience Comparison</h3>
<p>Table <a href="#tab:info_entered_with_model" data-reference-type="ref" data-reference="tab:info_entered_with_model">[tab:info_entered_with_model]</a> shows the information sources utilized by the apps as they carry out the various tasks related to the movie ticket booking context. The label <em>APP</em> denotes information generated by the app, <em>USER</em> denotes information entered by the user for the first time, and <em>GET</em> denotes information retrieved from the Context Database. Columns contains <em>Movie</em> fields and rows contain apps. The apps retrieve the movie fields from the Context Database which saves the user the effort of entering the information into the app. Compared to the number of times the user had to enter information in apps in Table <a href="#tab:info_entered" data-reference-type="ref" data-reference="tab:info_entered">[tab:info_entered]</a>, the user has to enter the information only the first time as the apps retrieve the stored information from the Context Database.</p>
<table id="info_entered_with_model">
    <tr>
        <td>App used</td>
        <td>Movie Title</td>
        <td>Show Date/Time</td>
        <td>Attending Contacts</td>
        <td>Theater Location</td>
        <td>Ticket Info</td>
    </tr>
    <tr>
        <td>Booking</td>
        <td>USER</td>
        <td>USER</td>
        <td>NA</td>
        <td>USER</td>
        <td>APP</td>
    </tr>
    <tr>
        <td>Calendar</td>
        <td>GET</td>
        <td>GET</td>
        <td>USER</td>
        <td>GET</td>
        <td>GET</td>
    </tr>
    <tr>
        <td>Messages</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
    </tr>
    <tr>
        <td>Maps</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
    </tr>
    <tr>
        <td>Reminder</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
        <td>GET</td>
    </tr>
</table>
<p>A comparison of the effort made by the user can be made using Table <a href="#tab:info_entered" data-reference-type="ref" data-reference="tab:info_entered">[tab:info_entered]</a> and Table <a href="#tab:info_entered_with_model" data-reference-type="ref" data-reference="tab:info_entered_with_model">[tab:info_entered_with_model]</a> to count the number of steps taken by the user in each app with and without the use of the Contextual Data Sharing Model. It can be clearly seen that when apps use the Contextual Data Sharing Model, the user only needs to select the available information instead of entering it in the app. The effort required to select information already available can be considered to be less than the effort required to enter information by typing it or copying it. The demonstration of the model also shows features such as showing upcoming events to select the destination of routes in maps that were not possible earlier.</p>
<h3 id="sec:performance_of_context_database">Performance of Context Database</h3>
<h4 id="sub:inserting_entry_in_context_database">Inserting an <em>Event</em> entry in Context Database</h4>
<p>Table <a href="#tab:CP_I_E" data-reference-type="ref" data-reference="tab:CP_I_E">[tab:CP_I_E]</a> shows the time required to insert one <em>Event</em> entry in the Context Database where the total time includes the time required for unmarshaling values, inserting <em>Contact, Location,</em> and <em>Event</em> entries in their respective tables, creating relational entries in various tables, and checking for duplicates.</p>
<table id="tab:CP_I_E">
    <tr>
        <td>Entries</td>
        <td>t<sub>min</sub>(ms)</td>
        <td>t<sub>max</sub>(ms)</td>
        <td>t<sub>avg</sub>(ms)</td>
        <td>t<sub>stdev</sub>(ms)</td>
    </tr>
    <tr>
        <td>100</td>
        <td>1</td>
        <td>5</td>
        <td>1.65</td>
        <td>0.81</td>
    </tr>
    <tr>
        <td>500</td>
        <td>1</td>
        <td>5</td>
        <td>1.72</td>
        <td>1.02</td>
    </tr>
    <tr>
        <td>1000</td>
        <td>1</td>
        <td>5</td>
        <td>2.03</td>
        <td>1.14</td>
    </tr>
    <tr>
        <td>5000</td>
        <td>2</td>
        <td>9</td>
        <td>4.21</td>
        <td>1.60</td>
    </tr>
    <tr>
        <td>10000</td>
        <td>4</td>
        <td>19</td>
        <td>6.00</td>
        <td>2.28</td>
    </tr>
    <tr>
        <td>50000</td>
        <td>9</td>
        <td>49</td>
        <td>12.19</td>
        <td>6.51</td>
    </tr>
    <tr>
        <td>100000</td>
        <td>20</td>
        <td>119</td>
        <td>42.55</td>
        <td>12.08</td>
    </tr>
</table>
<h4 id="sub:retrieving_events_from_context_database">Retrieving <em>Events</em> from Context Database</h4>
<p>Table <a href="#tab:CP_G_E" data-reference-type="ref" data-reference="tab:CP_G_E">[tab:CP_G_E]</a> shows the time required to retrieve all <em>Event</em> entries from the Context Database where the query executed the required operations to performs joins over <em>Event, Contact, Location</em> and their relational tables to retrieve all associated information in a single row of the result.</p>
<table id="tab:CP_G_E">
    <tr>
        <td>Entries</td>
        <td>t<sup>min</sup>(ms)</td>
        <td>t<sup>max</sup>(ms)</td>
        <td>t<sup>avg</sup>(ms)</td>
        <td>t<sup>stdev</sup>(ms)</td>
    </tr>
    <tr>
        <td>100</td>
        <td>1</td>
        <td>5</td>
        <td>1.87</td>
        <td>0.87</td>
    </tr>
    <tr>
        <td>500</td>
        <td>1</td>
        <td>5</td>
        <td>2.11</td>
        <td>0.94</td>
    </tr>
    <tr>
        <td>1000</td>
        <td>1</td>
        <td>5</td>
        <td>2.34</td>
        <td>1.13</td>
    </tr>
    <tr>
        <td>5000</td>
        <td>3</td>
        <td>10</td>
        <td>5.42</td>
        <td>1.95</td>
    </tr>
    <tr>
        <td>10000</td>
        <td>9</td>
        <td>39</td>
        <td>12.05</td>
        <td>4.29</td>
    </tr>
    <tr>
        <td>50000</td>
        <td>10</td>
        <td>49</td>
        <td>15.83</td>
        <td>6.98</td>
    </tr>
    <tr>
        <td>100000</td>
        <td>20</td>
        <td>137</td>
        <td>31.51</td>
        <td>15.73</td>
    </tr>
</table>
<h3 id="sec:performance_of_context_manager">Performance of Context Manager</h3>
<h4 id="sub:inserting_event_entries_through_context_manager">Inserting an <em>Event</em> entry through Context Manager</h4>
<p>Table <a href="#tab:CM_I_E" data-reference-type="ref" data-reference="tab:CM_I_E">[tab:CM_I_E]</a> shows the time required to insert one <em>Event</em> context through the Context Manager where the total time includes the time required to perform error and validation checks, the IPC between user app and the Content Provider,<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> checking for duplicates, and inserting the entry in the Context Database.</p>
<table id="tab:CM_I_E">
    <tr>
        <td>Entries</td>
        <td>t<sup>min</sup>(ms)</td>
        <td>t<sup>max</sup>(ms)</td>
        <td>t<sup>avg</sup>(ms)</td>
        <td>t<sup>stdev</sup>(ms)</td>
    </tr>
    <tr>
        <td>100</td>
        <td>1</td>
        <td>25</td>
        <td>1.70</td>
        <td>3.10</td>
    </tr>
    <tr>
        <td>500</td>
        <td>2</td>
        <td>47</td>
        <td>2.90</td>
        <td>5.01</td>
    </tr>
    <tr>
        <td>1000</td>
        <td>5</td>
        <td>58</td>
        <td>6.77</td>
        <td>7.41</td>
    </tr>
    <tr>
        <td>5000</td>
        <td>25</td>
        <td>243</td>
        <td>35.80</td>
        <td>34.02</td>
    </tr>
    <tr>
        <td>10000</td>
        <td>51</td>
        <td>491</td>
        <td>62.34</td>
        <td>48.86</td>
    </tr>
    <tr>
        <td>50000</td>
        <td>74</td>
        <td>783</td>
        <td>89.02</td>
        <td>89.18</td>
    </tr>
    <tr>
        <td>100000</td>
        <td>100</td>
        <td>1176</td>
        <td>130.20</td>
        <td>137.60</td>
    </tr>
</table>
<h4 id="sub:retrieving_events_through_context_manager">Retrieving <em>Events</em> through Context Manager</h4>
<p>Table <a href="#tab:CM_G_E" data-reference-type="ref" data-reference="tab:CM_G_E">[tab:CM_G_E]</a> shows the time required by the Context Manager to retrieve all <em>Event</em> entries from the Context Database where the total time includes the time required to execute the database query, perform the IPC between Content Provider and user app, and instantiate <em>Event</em> objects in the user app’s data space.<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a></p>
<table id="tab:CM_G_E">
    <tr>
        <td>Entries</td>
        <td>t<sup>min</sup>(ms)</td>
        <td>t<sup>max</sup>(ms)</td>
        <td>t<sup>avg</sup>(ms)</td>
        <td>t<sup>stdev</sup>(ms)</td>
    </tr>
    <tr>
        <td>100</td>
        <td>10</td>
        <td>39</td>
        <td>16.72</td>
        <td>4.60</td>
    </tr>
    <tr>
        <td>500</td>
        <td>100</td>
        <td>198</td>
        <td>120.61</td>
        <td>10.05</td>
    </tr>
    <tr>
        <td>1000</td>
        <td>200</td>
        <td>388</td>
        <td>240.95</td>
        <td>16.28</td>
    </tr>
    <tr>
        <td>5000</td>
        <td>500</td>
        <td>1781</td>
        <td>663.56</td>
        <td>115.86</td>
    </tr>
    <tr>
        <td>10000</td>
        <td>2000</td>
        <td>4896</td>
        <td>2265.74</td>
        <td>364.46</td>
    </tr>
    <tr>
        <td>50000</td>
        <td>5000</td>
        <td>10192</td>
        <td>6681.94</td>
        <td>712.68</td>
    </tr>
    <tr>
        <td>100000</td>
        <td>10024</td>
        <td>18094</td>
        <td>11459.12</td>
        <td>1429.04</td>
    </tr>
</table>
<h3 id="sec:comparison_of_insert_and_retrieval_times">Comparison of Insert and Retrieval times</h3>
<p>A comparison of the time taken by the insert and retrieve operations of the Context Manager is given in Fig. <a href="#fig:performance" data-reference-type="ref" data-reference="fig:performance">[fig:performance]</a>. The graph is plotted by comparing the range of values containing the minimum (t<sub>min</sub>), maximum (t<sub>max</sub>) and average time (t<sub>avg</sub>) required for an operation with the number of records in Context Database.</p>
<h5 class="unnumbered" id="observations">Observations</h5>
<p>Observing the graph and the associated tables leads to the following points:</p>
<ol>
<li><p>The time required for inserting contexts is comparably less than the time required for retrieving contexts;</p></li>
<li><p>There is substantial deviation between the minimum and maximum values;</p></li>
<li><p>The standard deviation is closer to the minimum values, which signifies better average performance;</p></li>
<li><p>The increase in time is almost linear compared to the increase in number of records;</p></li>
<li><p>There is a sudden increase in the values at around <em>n=500</em>;<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a></p></li>
<li><p>For most of the time, the average is closer to the minimum values;</p></li>
<li><p>The average retrieval time reaches <em>t=120ms<span class="math inline"><em>a</em><em>t</em><em>a</em><em>b</em><em>o</em><em>u</em><em>t</em></span>n=100</em>.</p></li>
</ol>
<h5 class="unnumbered" id="conclusions">Conclusions</h5>
<p>The observations lead to the following conclusions:</p>
<ol>
<li><p>The minimum and average insertion values at large database sizes are within an acceptable range for responsiveness in UI (0-100ms <span class="citation" data-cites="ResponseTime"><a href="#ref-ResponseTime" role="doc-biblioref">[86]</a></span>);</p></li>
<li><p>The maximum values show the extent of fluctuations possible during operation;</p></li>
<li><p>The number of entries returned in results should be restricted to around <em>n=100</em> to keep the time within an acceptable range.</p></li>
</ol>
<h3 id="sec:cpu_load_caused_by_context_manager">CPU load during retrieval operations</h3>
<p>The impact of the Contextual Data Sharing Model and its operations on CPU performance can be seen in Fig. <a href="#fig:cpuload" data-reference-type="ref" data-reference="fig:cpuload">[fig:cpuload]</a>. It shows the CPU load for retrieving <em>Event</em> contexts through the Context Manager. The total number of <em>Event</em> entries retrieved from the Context Database was <em>n=10000</em>. The total time required for the operation is <em>12.5s</em>, and includes the time for UI interactions within the app used to run the test. In the figure, the horizontal axis depicts the run-time given in seconds, and the vertical axis depicts the CPU usage as a percentage. The retrieved <em>Event</em> contexts are displayed on screen using a List View.<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a></p>
<p>The various operations that take place at different time instances are:</p>
<ul>
<li><p><em>t= 0s to 3.2s</em>: No activity. Some spikes in the CPU load can be attributed to the management of UI elements and memory by the system;</p></li>
<li><p><em>t= 3.2s</em>: UI interaction which sends a request to the Context Manager for all <em>Event</em> contexts. The Context Manager constructs the appropriate query and forwards it to the Context Database;</p></li>
<li><p><em>t= 3.3s to 3.6s</em>: The Context Database receives the request, parses it, and executes the query on the SQLite database to retrieve all <em>Event</em> entries. It then sends these back to the Context Manager;</p></li>
<li><p><em>t= 3.6s to 3.9s</em>: The time taken by the IPC mechanism to send the data from Context Database to Context Manager;<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a></p></li>
<li><p><em>t= 3.9s to 5.5s</em>: The Context Manager receives the entries and instantiates <em>Event</em> objects;</p></li>
<li><p><em>t= 5.5s to 10.7s</em>: The app receives the references to the <em>Event</em> objects and adds them to a ListView which is drawn on the screen;</p></li>
<li><p><em>t= 10.7s onwards</em>: UI interactions within the app such as closing the ListView and exiting the app.</p></li>
</ul>
<p>The total duration of the operations from sending the request until displaying the results on screen is about <em>t=7.5s</em>, which is well outside the acceptable range for UI interactions. Most of this time is spent instantiating the objects and drawing them on screen. If the number of entries retrieved from the database is restricted to <span class="math inline"><em>n</em> = 100</span> using the analysis of Fig. <a href="#fig:performance" data-reference-type="ref" data-reference="fig:performance">[fig:performance]</a>, it would reduce the CPU time and memory required for the operation. This will allow the app to display the results in less time which allows for fluid user interactions. The average CPU load at all times is well below 50%, which can be considered as not being under stress. This allows the CPU to run other apps and operations in the background. If an app wishes to perform operations that may take significant time to execute and stall UI operations, Android provides various mechanism to execute operations on another thread to prevent freezing the UI. In this case, the retrieval operation takes a significant amount of time to complete, and therefore must be executed on a non-UI thread.</p>
<h3 id="sec:metrics_summary">Summary</h3>
<p>The performance of the Contextual Data Sharing Model depends on a number of factors, amongst which the number of records in the database is the major factor that affects the performance of the operations. The time required for executing insert operations is within an acceptable range for higher database sizes, while the time required for retrieving entries from the database crosses the range for responsiveness in UI at about <em>n=100</em>. Limiting the number of entries returned from a query to 100 will allow operations to complete in an acceptable time and provide better responsiveness in UI.</p>
<p>Further testing and experimentation of the various operations need to be performed over different use cases as apps use operations in different ways. The performance of multiple queries executed concurrently also needs to be tested. The number of apps using the Context Database and the Contextual Data Sharing Model can also affect the performance of operations. Devices differing in specifications and environments will also have an impact on the performance of the model. All these factors indicate the need for extensive future testing of the model in a range of use cases and devices.</p>
<h1 id="this-research-and-its-future-potential">This Research and its Future Potential</h1>
<h2 id="conclusion">Conclusion</h2>
<p><em>“The most important property of a program is whether it accomplishes the intention of its user.”</em></p>
<p>– <em>C.A.R. Hoare</em></p>
<p>The Contextual Data Sharing Model allows smartphone applications to utilize and share contextual information. The Context Definitions provide a uniform structure to the contextual information, which can be stored and shared through the Context Database. Apps query the Context Database to retrieve contextual information which saves the user the effort of entering or finding related information in multiple apps used within the same context.</p>
<p>An implementation of the model on Android is used to demonstrate the Contextual Data Sharing Model. It uses Java classes to represent Context Definitions, which are then instantiated as Java objects and provide a uniform representation of contextual information across apps and devices. The Context Database uses Android’s Content Provider interface with SQLite as the storage backend for context entries. The Context Manager acts as a middleware between the apps and the Context Database, and is implemented as a static Java class instantiated in the app’s process. The Context Definitions and the Context Manager classes are bundled together into a library which the developers can include in their project to use contexts and interact with the Context Database. Concerns and considerations related to the security permissions and performance of the model are discussed for an Android implementation.</p>
<p>The time required to complete various database operations and its relation to the size of the database is analyzed to identify its impact on performance and usability in the implementation. Conclusions regarding optimization of performance of the queries are also discussed. The impact of running operations on the device was analyzed and found to present no hindrance to the running of other apps on the device.</p>
<p>The demonstration of the movie ticket booking use case shows how apps utilize the Contextual Data Sharing Model to access information which otherwise would have been entered by the user. The resulting user experience reduces user effort and provides relevant information and services through recommendations and suggestions in the app. This allows the user to complete their tasks faster and access relevant information without performing additional steps. The availability of contextual information to apps offers an opportunity to design new features and services that were not previously possible.</p>
<p>The main goal of this research is to enable apps to use the information generated and stored on a device and create contextual services using this information. Apps can present users with services they are most likely require, which saves the efforts related to entering information multiple times across several apps. This leads to better features and an improved user experience due to the availability of contextual information across apps.</p>
<h2 id="future-work">Future Work</h2>
<p><em>“There’s always more information out there.”</em></p>
<p>– <em>Google’s 9 Principles of Innovation</em></p>
<p>The Contextual Data Sharing Model adapts existing approaches and techniques to create an innovative framework which allows apps to create contextual services based on the availability of information. The design and implementation discussed in this thesis is an unique attempt in research of this kind to provide apps with an usable framework utilizing the information already present within apps to create contextual services. The implementation is a proof-of-concept demonstration used to show the impact and viability of the Contextual Data Sharing Model. This research can be further expanded into several areas discussed in the sections below.</p>
<h3 class="unnumbered" id="sub:cloud_offloading">Extending to the Cloud</h3>
<p>The Context Database used in the implementation uses a SQLite database located on the device. By implementing or extending the Context Database with a database situated in the cloud, it is possible to offload operations which are not possible or feasible on the device. Additional features can be provided on the device by analyzing and mediating contexts between services in the cloud. This allows the contextual information to exist independently from a device, and can be used to share contexts across devices.</p>
<p>Having the Contextual Data Sharing Model extended into the cloud provides access to contextual information from more sources, which can be used to develop more powerful and useful services. This information can be provided to the users in the form of services relevant to their contexts but not present on any particular device. This creates an abstraction between devices and services as the information stored in the cloud can be utilized to provide the same or similar services on any device connected to the ecosystem.</p>
<p>The local datastore such as the one used in this implementation would be a part of the cloud model, and would act as a cache for the Context Database based in the cloud. This helps the performance and QoS of the model on a device as the operations are executed faster with a copy or cache of the datastore located on the device. This also allows apps to work with a limited set of information when access to the cloud is restricted.</p>
<h3 class="unnumbered" id="sub:additional_database">Using different Database Software</h3>
<p>The SQLite database used in the implementation was chosen due to its lightweight design, stability and availability on a large number of platforms. SQLite lacks several features and capabilities when compared to other database softwares like MySQL <span class="citation" data-cites="mysql"><a href="#ref-mysql" role="doc-biblioref">[87]</a></span> and PostgreSQL <span class="citation" data-cites="postgresql"><a href="#ref-postgresql" role="doc-biblioref">[88]</a></span>. This affects the design of the Contextual Data Sharing Model as all operations are based on the nature of queries executed in the Context Database. Different database implementations provide features such as ordering query results and filter results based on parameters, that can be used to return only those results that are contextually relevant. By utilizing other database implementations which provide additional features and services, the features of Contextual Data Sharing Model can also be extended.</p>
<p>One possible and interesting approach would be to use a NoSQL graph database as the storage medium for the Context Database. The graph database can be used to store the various relations and interactions between contexts, which can lead to several new and innovative features. Such an implementation would enable apps to leverage the relational information in the Context Database to design a new generation of contextual services. This approach is similar to data mining where data is analyzed for relations which can be used to provide contextual services.</p>
<h3 class="unnumbered" id="sub:more_context_types">Adding more Context types</h3>
<p>The four context types (<em>Location, Contact, Event</em> and <em>Movie</em>) discussed in this implementation were developed to provide a proof-of-concept demonstration of the design and working of Context Definitions. Using the Contextual Data Sharing Model on devices requires implementing more use cases as Context Definitions in order to identify and use a significant amount of contextual information. For example, the <em>Event</em> context type can be extended to commonly used types such as <em>Meeting, Movie, Concert, and Lunch</em>. New context types such as <em>Restaurant Booking, Article, Task, Project, Conversation, Quote, and Work</em> that reflect the activities performed by the users using the various apps will allow more relevant contextual information to be identified and utilized.</p>
<h3 class="unnumbered" id="sub:related_services_within_context_definitions">Storing related services within Context Definitions</h3>
<p>The design of Context Definitions and its implementation on Android entails storing the contextual information and its associated methods within a single object. The design can be modified to store services related to that context within the Context Definition itself. The model can be extended to tie in apps with the execution of these services in an abstract way. For example, by including weather and traffic services within an <em>Event</em> context, apps that display or use the events can also present this information without querying for weather or traffic data themselves. The system resolves the service request and queries the appropriate app installed on the system to get the required information. This approach allows apps to share services present on the device that can be used to provide related information in more useful ways.</p>
<h3 class="unnumbered" id="sub:application_on_wearable_devices">Potential for Wearable devices</h3>
<p>The Contextual Data Sharing Model described in this research is designed for smartphone applications. The year 2014 saw the introduction of wearable devices such as smartwatches and fitness trackers, some of which run the same platforms as smartphones. This creates a potential to adapt the Contextual Data Sharing Model for wearable devices.</p>
<p>Wearable devices have comparably lesser capabilities than a smartphone in terms of available memory, processor and screen space. The devices are designed to provide high accessibility to information by being present on the body of the user. Most of these devices require the use of a smartphone which acts as the hub of information which is then sent to the wearable device. The most common use of wearables is to display notifications which the user can interact with. This allows contextual information and services to be displayed to the user when required without requiring them to access a smartphone.</p>
<p>Although information can be displayed and interacted with on a wearable device, the capabilities of this interaction are much less as compared to a smartphone. Actions such as navigation and UI are restricted on a wearable device. This creates a need to show useful and related information so that the user does not have to navigate for the information or access it on the smartphone. This is a situation comparable to the capabilities of a smartphone and a computing device such as a laptop. The lesser capabilities of the smartphone creates a need for contextual services in apps which formed the motivation for developing the Contextual Data Sharing Model. The same motivation can be applied to develop or extend the Contextual Data Sharing Model for wearables.</p>
<h3 class="unnumbered" id="sub:internet_of_things_">Connecting with the Internet of Things (IoT)</h3>
<p>The Internet of Things (IoT) is the interconnection of uniquely identifiable embedded computing devices within the existing Internet infrastructure. IoT has the potential to offer advanced connectivity of devices, systems, and services that covers a variety of protocols, domains, and applications <span class="citation" data-cites="iotbook"><a href="#ref-iotbook" role="doc-biblioref">[89]</a></span>. The interconnection of these embedded devices, also known as smart objects, is expected to usher in automation in nearly all fields, while also enabling advanced applications like a Smart Grid <span class="citation" data-cites="smartgrid"><a href="#ref-smartgrid" role="doc-biblioref">[90]</a></span>. According to Gartner, there will be nearly 26 billion devices on the Internet of Things by 2020 <span class="citation" data-cites="gartneriot"><a href="#ref-gartneriot" role="doc-biblioref">[91]</a></span>. IoT is expected to generate large amounts of data from diverse locations that can be aggregated to create new application areas such as automation and smart homes <span class="citation" data-cites="iot18 iot19"><a href="#ref-iot18" role="doc-biblioref">[92]</a>, <a href="#ref-iot19" role="doc-biblioref">[93]</a></span>. This data can be utilized to provide a range of contextual services that allow the user to control and access their IoT devices as resources. Android and iOS have started to integrate IoT functionality by way of APIs that allow users to discover and interact with devices installed in their homes.<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> This creates the potential for integrating the Contextual Data Sharing Model with the IoT devices to provide services that offer users contextual control of their homes. For example, the lights and other IoT devices can be turned off whenever users leave their homes on a trip where they can monitor and control the appliances remotely. The users can also set a preference to turn up the heating in the house based on their expected arrival time.</p>
<h3 class="unnumbered" id="sub:implementing_contextual_data_sharing_model_on_ios">An iOS implementation</h3>
<p>The Contextual Data Sharing Model is designed to be platform agnostic with a bias towards being used on Android or iOS. Even though the implementation is demonstrated using Android, it is possible to implement the model and its components on iOS. The Context Database can utilize the same SQLite version along with the table schema for the backend, while the Context Definitions can be defined using classes in Objective-C or Swift. The challenge in realizing the iOS implementation is the communication between different apps and the Context Database, which cannot be performed using the existing data sharing methods available on the system. The components need to be executed as part of the system to make the API available to all apps on a global level and allow exchange of information outside the restrictions of the data sharing methods available to user apps.</p>
<h3 class="unnumbered" id="sub:a_contextual_ecosystem_of_apps_services_and_devices">Creating a Contextual Ecosystem of Apps, Services and Devices</h3>
<p>The Contextual Data Sharing Model can be expanded into several areas connected or associated with a user’s context. These include interacting with web services, applications on computing devices such as laptops, smartphones and wearable devices along with interactions with devices not owned by the user such as point of sale devices. Providing interactions and communications between all services the user interacts with allows the possibility of providing context-aware information and features on all these devices. This requires creating and adapting the Contextual Data Sharing Model for each device and platform, and consolidating the information gathered to make it available to services across devices. Such a contextual ecosystem of apps, services and devices will enable the user to interact with tasks on any device and service which creates a continuous user experience based on the user’s context.</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-gartner" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[1] </div><div class="csl-right-inline"><span>“<span class="nocase">Gartner Says Worldwide Traditional PC, Tablet, Ultramobile and Mobile Phone Shipments Are On Pace to Grow 6.9 Percent in 2014</span>,”</span> Jun-2014. </div></p>
</div>
<div id="ref-comScore_mobilelens" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[2] </div><div class="csl-right-inline"><span>“<span class="nocase">MobiLens - Understand Mobile Trends and Consumer Behavior</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-googleplay_apps" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[3] </div><div class="csl-right-inline">S. Keach, <span>“<span class="nocase">Microsoft says Windows Phone now touts 300,000 apps</span>,”</span> Aug-2014. </div></p>
</div>
<div id="ref-appstore_apps" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[4] </div><div class="csl-right-inline">S. Perez, <span>“<span class="nocase">iTunes App Store Now Has 1.2 Million Apps, Has Seen 75 Billion Downloads To Date</span>,”</span> Jun-2014. </div></p>
</div>
<div id="ref-googleplay_downloads" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[5] </div><div class="csl-right-inline">Phonearena.com, <span>“<span class="nocase">Android’s Google Play beats App Store with over 1 million apps, now officially largest</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-app_phones" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[6] </div><div class="csl-right-inline">D. Pogue, <span>“<span class="nocase">A Place to Put Your Apps</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-app_wordoftheyear" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[7] </div><div class="csl-right-inline">Americandialect.org, <span>“<span class="nocase">"App" voted 2010 word of the year by the American Dialect Society (UPDATED) American Dialect Society</span>,”</span> Nov-2014. </div></p>
</div>
<div id="ref-comScore_appsusage" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[8] </div><div class="csl-right-inline">S. Perez, <span>“<span class="nocase">comScore: In U.S. Mobile Market, Samsung, Android Top The Charts; Apps Overtake Web Browsing.</span>”</span> Sep-2014. </div></p>
</div>
<div id="ref-appusage_context" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[9] </div><div class="csl-right-inline">M. Böhmer, B. Hecht, J. Schöning, A. Krüger, and G. Bauer, <span>“<span class="nocase">Falling Asleep with Angry Birds, Facebook and Kindle: A Large Scale Study on Mobile Application Usage</span>,”</span> in <em><span class="nocase">Proceedings of the 13th International Conference on Human Computer Interaction with Mobile Devices and Services</span></em>, 2011, pp. 47–56, doi: <a href="https://doi.org/10.1145/2037373.2037383">10.1145/2037373.2037383</a>. </div></p>
</div>
<div id="ref-Sandboxing" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[10] </div><div class="csl-right-inline">K. W. Y. Au, Y. F. Zhou, Z. Huang, P. Gill, and D. Lie, <span>“<span class="nocase">Short Paper: A Look at Smartphone Permission Models</span>,”</span> in <em><span class="nocase">Proceedings of the 1st ACM Workshop on Security and Privacy in Smartphones and Mobile Devices</span></em>, 2011, pp. 63–68, doi: <a href="https://doi.org/10.1145/2046614.2046626">10.1145/2046614.2046626</a>. </div></p>
</div>
<div id="ref-ContextSysClassify" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[11] </div><div class="csl-right-inline">B. Chihani, E. Bertin, and N. Crespi, <span>“A comprehensive framework for context-aware communication services,”</span> in <em>Intelligence in next generation networks (ICIN), 2011 15th international conference on</em>, 2011, pp. 52–57, doi: <a href="https://doi.org/10.1109/ICIN.2011.6081102">10.1109/ICIN.2011.6081102</a>. </div></p>
</div>
<div id="ref-SMARTAPPS" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[12] </div><div class="csl-right-inline">M. Elgan, <span>“<span class="nocase">Smart apps think (so you don’t have to)</span>,”</span> Mar-2013. </div></p>
</div>
<div id="ref-Google:Now" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[13] </div><div class="csl-right-inline"><span>“<span>Google Now</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-GmailCards" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[14] </div><div class="csl-right-inline"><span>“<span class="nocase">About Gmail cards</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-mostpopularapps" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[15] </div><div class="csl-right-inline">A. Lella, <span>“<span>Top 25 Mobile Apps Dominated By The Largest Digital Media Brands</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-CalendarSunrise" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[16] </div><div class="csl-right-inline"><span>“<span>Sunrise Calendar</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-xcallback" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[17] </div><div class="csl-right-inline"><span>“<span class="nocase">x-Callback-Url - iOS Interapp Communication</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-CalendarFantastical" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[18] </div><div class="csl-right-inline"><span>“<span>Fantastical</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-Contextawarecomputing" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[19] </div><div class="csl-right-inline">B. Schilit, N. Adams, and R. Want, <span>“<span>Context-Aware Computing Applications</span>,”</span> in <em><span class="nocase">Proceedings of the 1994 First Workshop on Mobile Computing Systems and Applications</span></em>, 1994, pp. 85–90, doi: <a href="https://doi.org/10.1109/WMCSA.1994.16">10.1109/WMCSA.1994.16</a>. </div></p>
</div>
<div id="ref-Schilit:1994:DAM:2329093.2330030" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[20] </div><div class="csl-right-inline">B. N. Schilit and M. M. Theimer, <span>“<span class="nocase">Disseminating Active Map Information to Mobile Hosts</span>,”</span> <em>Netwrk. Mag. of Global Internetwkg.</em>, vol. 8, no. 5, pp. 22–32, Sep. 1994, doi: <a href="https://doi.org/10.1109/65.313011">10.1109/65.313011</a>. </div></p>
</div>
<div id="ref-contextmodelssurvey" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[21] </div><div class="csl-right-inline">C. Bolchini, C. A. Curino, E. Quintarelli, F. A. Schreiber, and L. Tanca, <span>“<span class="nocase">A Data-oriented Survey of Context Models</span>,”</span> <em>SIGMOD Rec.</em>, vol. 36, no. 4, pp. 19–26, Dec. 2007, doi: <a href="https://doi.org/10.1145/1361348.1361353">10.1145/1361348.1361353</a>. </div></p>
</div>
<div id="ref-ContextDef" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[22] </div><div class="csl-right-inline">A. K. Dey, <span>“<span class="nocase">Understanding and Using Context</span>,”</span> <em>Personal Ubiquitous Comput.</em>, vol. 5, no. 1, pp. 4–7, Jan. 2001, doi: <a href="https://doi.org/10.1007/s007790170019">10.1007/s007790170019</a>. </div></p>
</div>
<div id="ref-ContextOpDef" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[23] </div><div class="csl-right-inline">A. Zimmermann, A. Lorenz, and R. Oppermann, <span>“<span class="nocase">An Operational Definition of Context</span>,”</span> in <em><span class="nocase">Proceedings of the 6th International and Interdisciplinary Conference on Modeling and Using Context</span></em>, 2007, pp. 558–571. </div></p>
</div>
<div id="ref-TaskCentral1" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[24] </div><div class="csl-right-inline">J. L. Crowley, J. Coutaz, G. Rey, and P. Reignier, <span>“<span class="nocase">Perceptual Components for Context Aware Computing</span>,”</span> in <em><span class="nocase">Proceedings of the 4th International Conference on Ubiquitous Computing</span></em>, 2002, pp. 117–134. </div></p>
</div>
<div id="ref-TaskCentral2" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[25] </div><div class="csl-right-inline">A. Kofod-petersen and J. Cassens, <span>“<span class="nocase">Using activity theory to model context awareness</span>,”</span> in <em><span class="nocase">Modeling and Retrieval of Context: Second International Workshop, MRC 2005, Revised Selected Papers. Volume 3946 of Lecture Notes in Computer Science</span></em>, 2006, pp. 1–17. </div></p>
</div>
<div id="ref-TaskCentral3" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[26] </div><div class="csl-right-inline">K. Henricksen and J. Indulska, <span>“<span class="nocase">Developing Context-aware Pervasive Computing Applications: Models and Approach</span>,”</span> <em>Pervasive Mob. Comput.</em>, vol. 2, no. 1, pp. 37–64, Feb. 2006, doi: <a href="https://doi.org/10.1016/j.pmcj.2005.07.003">10.1016/j.pmcj.2005.07.003</a>. </div></p>
</div>
<div id="ref-ContextDef2" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[27] </div><div class="csl-right-inline">A. K. Dey, G. D. Abowd, and D. Salber, <span>“<span class="nocase">A Conceptual Framework and a Toolkit for Supporting the Rapid Prototyping of Context-aware Applications</span>,”</span> <em>Hum.-Comput. Interact.</em>, vol. 16, no. 2, pp. 97–166, Dec. 2001, doi: <a href="https://doi.org/10.1207/S15327051HCI16234\_02">10.1207/S15327051HCI16234\_02</a>. </div></p>
</div>
<div id="ref-ContextDef3" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[28] </div><div class="csl-right-inline">G. D. Abowd, A. K. Dey, P. J. Brown, N. Davies, M. Smith, and P. Steggles, <span>“<span class="nocase">Towards a Better Understanding of Context and Context-Awareness</span>,”</span> in <em><span class="nocase">Proceedings of the 1st International Symposium on Handheld and Ubiquitous Computing</span></em>, 1999, pp. 304–307. </div></p>
</div>
<div id="ref-TaskCentral4" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[29] </div><div class="csl-right-inline">H. Chen, <span>“<span class="nocase">An Intelligent Broker for Context-Aware Systems</span>,”</span> in <em><span class="nocase">In Adjunct Proceedings of Ubicomp</span></em>, 2003, pp. 183–184. </div></p>
</div>
<div id="ref-MobileContext1" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[30] </div><div class="csl-right-inline">A. Battestini, C. Del Rosso, A. Flanagan, and M. Miettinen, <span>“Creating next generation applications and services for mobile devices: Challenges and opportunities,”</span> in <em>Personal, indoor and mobile radio communications, 2007. PIMRC 2007. IEEE 18th international symposium on</em>, 2007, pp. 1–4, doi: <a href="https://doi.org/10.1109/PIMRC.2007.4394846">10.1109/PIMRC.2007.4394846</a>. </div></p>
</div>
<div id="ref-Battestini_analysisand" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[31] </div><div class="csl-right-inline">A. Battestini and J. A. Flanagan, <span>“<span class="nocase">Analysis and Cluster Based Modelling and Recognition of Context in a Mobile Environment</span>.”</span> </div></p>
</div>
<div id="ref-malikmahmud" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[32] </div><div class="csl-right-inline">N. Malik and U. Mahmud, <span>“<span class="nocase">Future challenges in context-aware computing</span>,”</span> in <em><span class="nocase">Proceedings of the IADIS</span></em>, 2007, pp. 306–310. </div></p>
</div>
<div id="ref-Strang04acontext" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[33] </div><div class="csl-right-inline">T. Strang and C. Linnhoff-Popien, <span>“<span>A Context Modeling Survey</span>,”</span> in <em><span class="nocase">In: Workshop on Advanced Context Modelling, Reasoning and Management, UbiComp 2004 - The Sixth International Conference on Ubiquitous Computing, Nottingham/England</span></em>, 2004. </div></p>
</div>
<div id="ref-RCSM" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[34] </div><div class="csl-right-inline">S. S. Yau, F. Karim, Y. Wang, B. Wang, and S. K. S. Gupta, <span>“Reconfigurable context-sensitive middleware for pervasive computing,”</span> <em>Pervasive Computing, IEEE</em>, vol. 1, no. 3, pp. 33–40, 2002, doi: <a href="https://doi.org/10.1109/MPRV.2002.1037720">10.1109/MPRV.2002.1037720</a>. </div></p>
</div>
<div id="ref-access_schemes" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[35] </div><div class="csl-right-inline">A. Klein, C. Mannweiler, J. Schneider, and H. D. Schotten, <span>“Access schemes for mobile cloud computing,”</span> in <em>Mobile data management (MDM), 2010 eleventh international conference on</em>, 2010, pp. 387–392, doi: <a href="https://doi.org/10.1109/MDM.2010.79">10.1109/MDM.2010.79</a>. </div></p>
</div>
<div id="ref-ContextAwareFramework" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[36] </div><div class="csl-right-inline">P. Korpipaa, J. Mantyjarvi, J. Kela, H. Keranen, and E.-J. Malm, <span>“<span class="nocase">Managing Context Information in Mobile Devices</span>,”</span> <em>IEEE Pervasive Computing</em>, vol. 2, no. 3, pp. 42–51, Jul. 2003, doi: <a href="https://doi.org/10.1109/MPRV.2003.1228526">10.1109/MPRV.2003.1228526</a>. </div></p>
</div>
<div id="ref-contextjit" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[37] </div><div class="csl-right-inline">A. Alidin and F. Crestani, <span>“Context acquisition in just-in-time mobile information retrieval,”</span> in <em>Information retrieval knowledge management (CAMP), 2012 international conference on</em>, 2012, pp. 203–207, doi: <a href="https://doi.org/10.1109/InfRKM.2012.6205002">10.1109/InfRKM.2012.6205002</a>. </div></p>
</div>
<div id="ref-Leake99selectingtask-relevant" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[38] </div><div class="csl-right-inline">D. B. Leake, R. Scherle, J. Budzik, and K. Hammond, <span>“<span class="nocase">Selecting Task-Relevant Sources for Just-in-Time Retrieval</span>,”</span> in <em><span class="nocase">In Proceedings of the AAAI-99 Workshop on Intelligent Information Systems, Menlo Park, CA</span></em>, 1999. </div></p>
</div>
<div id="ref-contextdatamanagement" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[39] </div><div class="csl-right-inline">P. Falcarin, M. Valla, J. Yu, C. Licciardi, C. Frà, and L. Lamorte, <span>“Context data management: An architectural framework for context-aware services,”</span> <em>Service Oriented Computing and Applications</em>, vol. 7, no. 2, pp. 151–168, 2013, doi: <a href="https://doi.org/10.1007/s11761-012-0115-1">10.1007/s11761-012-0115-1</a>. [Online]. Available: <a href="http://dx.doi.org/10.1007/s11761-012-0115-1">http://dx.doi.org/10.1007/s11761-012-0115-1</a></div></p>
</div>
<div id="ref-contextdirectory" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[40] </div><div class="csl-right-inline">R. Lowe, P. Mandl, and M. Weber, <span>“Context directory: A context-aware service for mobile context-aware computing applications by the example of google android,”</span> in <em>Pervasive computing and communications workshops (PERCOM workshops), 2012 IEEE international conference on</em>, 2012, pp. 76–81, doi: <a href="https://doi.org/10.1109/PerComW.2012.6197616">10.1109/PerComW.2012.6197616</a>. </div></p>
</div>
<div id="ref-MobileCloud1" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[41] </div><div class="csl-right-inline">B.-G. Chun, S. Ihm, P. Maniatis, M. Naik, and A. Patti, <span>“<span class="nocase">CloneCloud: Elastic Execution Between Mobile Device and Cloud</span>,”</span> in <em><span class="nocase">Proceedings of the Sixth Conference on Computer Systems</span></em>, 2011, pp. 301–314, doi: <a href="https://doi.org/10.1145/1966445.1966473">10.1145/1966445.1966473</a>. </div></p>
</div>
<div id="ref-MobileCloud2" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[42] </div><div class="csl-right-inline">E. Cuervo <em>et al.</em>, <span>“<span class="nocase">MAUI: Making Smartphones Last Longer with Code Offload</span>,”</span> in <em><span class="nocase">Proceedings of the 8th International Conference on Mobile Systems, Applications, and Services</span></em>, 2010, pp. 49–62, doi: <a href="https://doi.org/10.1145/1814433.1814441">10.1145/1814433.1814441</a>. </div></p>
</div>
<div id="ref-MobileCloud4" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[43] </div><div class="csl-right-inline">A. Fahim, A. Mtibaa, and K. A. Harras, <span>“<span class="nocase">Making the Case for Computational Offloading in Mobile Device Clouds</span>,”</span> in <em><span class="nocase">Proceedings of the 19th Annual International Conference on Mobile Computing &amp;#38; Networking</span></em>, 2013, pp. 203–205, doi: <a href="https://doi.org/10.1145/2500423.2504576">10.1145/2500423.2504576</a>. </div></p>
</div>
<div id="ref-MobileCloud5" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[44] </div><div class="csl-right-inline">N. Fernando, S. W. Loke, and W. Rahayu, <span>“<span class="nocase">Mobile cloud computing: A survey </span>,”</span> <em>Future Generation Computer Systems</em>, vol. 29, no. 1, pp. 84–106, 2013, doi: <a href="http://dx.doi.org/10.1016/j.future.2012.05.023">http://dx.doi.org/10.1016/j.future.2012.05.023</a>. </div></p>
</div>
<div id="ref-MobileCloud3" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[45] </div><div class="csl-right-inline">K. Kumar and Y.-H. Lu, <span>“<span class="nocase">Cloud Computing for Mobile Users: Can Offloading Computation Save Energy?</span>”</span> <em>Computer</em>, vol. 43, no. 4, pp. 51–56, Apr. 2010, doi: <a href="https://doi.org/10.1109/MC.2010.98">10.1109/MC.2010.98</a>. </div></p>
</div>
<div id="ref-COSMOS" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[46] </div><div class="csl-right-inline">J. Sankaranarayanan, H. Hacigumus, and J. Tatemura, <span>“COSMOS: A platform for seamless mobile services in the cloud,”</span> in <em>Mobile data management (MDM), 2011 12th IEEE international conference on</em>, 2011, vol. 1, pp. 303–312, doi: <a href="https://doi.org/10.1109/MDM.2011.68">10.1109/MDM.2011.68</a>. </div></p>
</div>
<div id="ref-CPA" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[47] </div><div class="csl-right-inline">M. J. O’Sullivan and D. Grigoras, <span>“The cloud personal assistant for providing services to mobile clients,”</span> in <em>Service oriented system engineering (SOSE), 2013 IEEE 7th international symposium on</em>, 2013, pp. 478–485, doi: <a href="https://doi.org/10.1109/SOSE.2013.39">10.1109/SOSE.2013.39</a>. </div></p>
</div>
<div id="ref-Baldauf04asurvey" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[48] </div><div class="csl-right-inline">M. Baldauf and S. Dustdar, <span>“<span class="nocase">A Survey on Context-aware systems</span>,”</span> <em>INTERNATIONAL JOURNAL OF AD HOC AND UBIQUITOUS COMPUTING</em>, p. 2004, 2004. </div></p>
</div>
<div id="ref-Pascoe:1998:AGC:857199.858020" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[49] </div><div class="csl-right-inline">Mr. J. Pascoe, <span>“<span class="nocase">Adding Generic Contextual Capabilities to Wearable Computers</span>,”</span> in <em><span class="nocase">Proceedings of the 2Nd IEEE International Symposium on Wearable Computers</span></em>, 1998, pp. 92–. </div></p>
</div>
<div id="ref-RDF" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[50] </div><div class="csl-right-inline">W3C, <span>“<span class="nocase">Resource Description Framework (RDF) Model and Syntax Specification</span>,”</span> Jan-1999. </div></p>
</div>
<div id="ref-OWL" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[51] </div><div class="csl-right-inline">W3C, <span>“<span>OWL 2 Web Ontology Language Document Overview (Second Edition)</span>,”</span> Dec-2012. </div></p>
</div>
<div id="ref-WebServices" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[52] </div><div class="csl-right-inline">F. Curbera, M. Duftler, R. Khalaf, W. Nagy, N. Mukhi, and S. Weerawarana, <span>“<span class="nocase">Unraveling the Web Services Web: An Introduction to SOAP, WSDL, and UDDI</span>,”</span> <em>IEEE Internet Computing</em>, vol. 6, no. 2, pp. 86–93, Mar. 2002, doi: <a href="https://doi.org/10.1109/4236.991449">10.1109/4236.991449</a>. </div></p>
</div>
<div id="ref-JSON" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[53] </div><div class="csl-right-inline"><span>“<span>JSON - JavaScript Object Notation</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-Siri" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[54] </div><div class="csl-right-inline"><span>“<span>Siri</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-Cortana" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[55] </div><div class="csl-right-inline"><span>“<span>Cortana</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-def_datasharing" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[56] </div><div class="csl-right-inline"><span>“<span class="nocase">data sharing. (n.d.) Computer Desktop Encyclopedia</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-AndroidIntents" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[57] </div><div class="csl-right-inline"><span>“<span class="nocase">Intents and Intent Filters</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-iOSCoreData" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[58] </div><div class="csl-right-inline"><span>“<span class="nocase">Data Management in iOS</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-manifest" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[59] </div><div class="csl-right-inline"><span>“<span>App Manifest</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-iOS_uri_schemes" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[60] </div><div class="csl-right-inline"><span>“<span>Apple URL Scheme Reference</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-android_common_intents" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[61] </div><div class="csl-right-inline"><span>“<span>Common Intents</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-onelink" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[62] </div><div class="csl-right-inline"><span>“<span class="nocase">Introducing OneLink - One smart link to rule them ALL</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-urx" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[63] </div><div class="csl-right-inline"><span>“<span class="nocase">URX, Relevant and Native Deep Link Mobile Advertising</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-applink" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[64] </div><div class="csl-right-inline"><span>“<span>App Links Overview</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-appurl" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[65] </div><div class="csl-right-inline"><span>“<span class="nocase">AppURL connects native apps to the web with http URLs</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-appindexing" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[66] </div><div class="csl-right-inline"><span>“<span class="nocase">App Indexing for Google Search - A better search experience for apps and users</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-eventkit" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[67] </div><div class="csl-right-inline"><span>“<span class="nocase">Calendar and Reminders Programming Guide</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-addressbook" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[68] </div><div class="csl-right-inline"><span>“<span class="nocase">Address Book Programming Guide for iOS</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-ContentProvider" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[69] </div><div class="csl-right-inline"><span>“<span>Android - Content Provider</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-saf" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[70] </div><div class="csl-right-inline"><span>“<span>Storage Access Framework</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-ios_documentpicker" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[71] </div><div class="csl-right-inline"><span>“<span>Document Picker Programming Guide</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-pasteboard" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[72] </div><div class="csl-right-inline"><span>“<span>UIPasteboard Class Reference</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-ios_ipc" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[73] </div><div class="csl-right-inline"><span>“<span>Inter-App Communication</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-keychain" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[74] </div><div class="csl-right-inline"><span>“<span>Keychain Services Programming Guide</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-icloud" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[75] </div><div class="csl-right-inline"><span>“<span class="nocase">iCloud for Developers</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-broadcast" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[76] </div><div class="csl-right-inline"><span>“<span>BroadcastReceiver</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-service" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[77] </div><div class="csl-right-inline"><span>“<span>Services</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-JavaMultipleInheritance" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[78] </div><div class="csl-right-inline">B. Venners, <span>“<span class="nocase">Designing with interfaces : One programmer’s struggle to understand the interface</span>,”</span> Dec-1998. </div></p>
</div>
<div id="ref-RDBMSHierarchy" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[79] </div><div class="csl-right-inline">T. Arvin, <span>“<span class="nocase">Troels’ links: Relational database systems</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-NoSQL" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[80] </div><div class="csl-right-inline">M. Rouse, <span>“<span>NoSQL (Not Only SQL)</span>,”</span> Oct-2014. </div></p>
</div>
<div id="ref-SQLite" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[81] </div><div class="csl-right-inline"><span>“<span>SQLite</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-Parcelable" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[82] </div><div class="csl-right-inline"><span>“<span>Android - Parcelable</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-JavaOOP" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[83] </div><div class="csl-right-inline">Oracle.com, <span>“<span>Lesson 8: Object-Oriented Programming</span>,”</span> Sep-2014. </div></p>
</div>
<div id="ref-PagingAlgo" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[84] </div><div class="csl-right-inline">A. S. Tanenbaum, <em><span>Modern Operating Systems</span></em>, 3rd ed. Upper Saddle River, NJ, USA: Prentice Hall Press, 2007, p. 288. </div></p>
</div>
<div id="ref-android_permissions" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[85] </div><div class="csl-right-inline"><span>“<span>System Permissions</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-ResponseTime" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[86] </div><div class="csl-right-inline">M. Jovic and M. Hauswirth, <span>“Performance testing of GUI applications,”</span> in <em>Software testing, verification, and validation workshops (ICSTW), 2010 third international conference on</em>, 2010, pp. 247–251, doi: <a href="https://doi.org/10.1109/ICSTW.2010.27">10.1109/ICSTW.2010.27</a>. </div></p>
</div>
<div id="ref-mysql" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[87] </div><div class="csl-right-inline"><span>“<span class="nocase">MySQL - The world’s most popular open source database</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-postgresql" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[88] </div><div class="csl-right-inline"><span>“<span class="nocase">PostgreSQL - The world’s most advanced open source database</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-iotbook" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[89] </div><div class="csl-right-inline">J. Holler, V. Tsiatsis, C. Mulligan, S. Karnouskos, S. Avesand, and D. Boyle, <em>From machine-to-machine to the internet of things: Introduction to a new age of intelligence</em>. Elsevier, 2014. </div></p>
</div>
<div id="ref-smartgrid" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[90] </div><div class="csl-right-inline">O. Monnier, <span>“<span class="nocase">A smarter grid with the Internet of Things, Texas Instruments</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-gartneriot" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[91] </div><div class="csl-right-inline">Gartner, <span>“<span class="nocase">Gartner Says the Internet of Things Installed Base Will Grow to 26 Billion Units By 2020</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-iot18" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[92] </div><div class="csl-right-inline">B. Violino, <span>“<span class="nocase">The ’Internet of things’ will mean really, really big data, Inforworld</span>,”</span> Dec-2014. </div></p>
</div>
<div id="ref-iot19" class="csl-entry" role="doc-biblioentry">
<p><div class="csl-left-margin">[93] </div><div class="csl-right-inline">M. Hogan, <span>“<span class="nocase">The ’The Internet of Things Database’ Data Management Requirements, ScaleDB</span>,”</span> Jul-2014. </div></p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The first iOS device was the iPhone, released in 2007; and the first Android device was the HTC Dream, released in 2008<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The Google Play Store (Android) and the App Store (iOS) have over 1.3 million apps published <span class="citation" data-cites="googleplay_apps appstore_apps"><a href="#ref-googleplay_apps" role="doc-biblioref">[3]</a>, <a href="#ref-appstore_apps" role="doc-biblioref">[4]</a></span> and over 50 billion downloads <span class="citation" data-cites="googleplay_downloads appstore_apps"><a href="#ref-appstore_apps" role="doc-biblioref">[4]</a>, <a href="#ref-googleplay_downloads" role="doc-biblioref">[5]</a></span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>As of January 01, 2015 Sunrise has the most number of connected services (16) integrated in a calendar app. A full list of services can be found at https://calendar.sunrise.am/<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>MobiLife is a user-centric architecture that aims to provide communication and sharing of items in order to manage complex lifestyles. <em>http://www.ist-mobilife.org</em><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Dalvik is the process virtual machine (VM) in Android and executes applications written for Android. Reflection is the ability of a computer program to examine and modify the structure and behavior (specifically the values, meta-data, properties and functions) of the program at runtime.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>An alternative title with a human-readable definition is available at <a href="http://dublincore.org/documents/dcmi-terms/index.shtml">http://dublincore.org/documents/dcmi-terms/index.shtml</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>The Knowledge Graph is a knowledge base used by Google to enhance its search engine’s search results with semantic-search information gathered from a wide variety of sources. More information can be found at <a href="http://www.google.ie/insidesearch/features/search/knowledge.html">http://www.google.ie/insidesearch/features/search/knowledge.html</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>POSIX is an acronym for Portable Operating System Interface, and defines the application programming interface (API) and utility interfaces for software compatibility with variants of Unix and other operating systems. Android uses the Linux kernel, while iOS uses Darwin, both of which are loosely based on POSIX systems.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>An Activity is an application component that provides a screen with which users can interact in order to do something, such as dial a number, take a photo, send an email, or view a map. Each activity is given a window in which to draw its user interface. The window typically fills the screen, but may be smaller than the screen and float on top of other windows.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>In Android, each app is defined by a unique package namespace. In order to start another app’s activities, the app’s package and the activities’ name must be known. Also, the app must declare the necessary permissions to let another app start its activities.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>source: http://www.compiletimeerror.com/2013/12/content-provider-in-android.html<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>It is possible to access data in a Content Provider without proper access permissions by sending an intent to an application that already has the required permissions and receiving back a result intent containing <em>URI permissions</em>. These permissions are limited to a specific content URI that lasts until the activity that receives them is terminated.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>Available NoSQL graph database for Android include Titan (<a href="https://wuman.github.io/titan-android/">https://wuman.github.io/titan-android/</a>), Neo4j (<a href="https://github.com/neo4j-contrib/neo4j-mobile-android">https://github.com/neo4j-contrib/neo4j-mobile-android</a>) and Sparksee (<a href="http://www.sparsity-technologies.com/">http://www.sparsity-technologies.com/</a>), all of which are under development and do not have the level of stability suitable for mass adoption.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>Parcelable and Serialization are implementations used for marshaling and unmarshaling Java objects. Android’s Parcelable implementation allows objects to read and write from Parcels (data object) which can contain flattened data inside message containers, which offers better performance results on constrained platforms like Android.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>Some devices are shipped with a different SQLite version as manufacturers install an updated version on the device. Version 3.7.11 is the version of SQLite binary shipped in the KitKat release dated 01-Nov-2013.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>Since every entry in the extended context’s table has a corresponding entry in the parent context’s table, the parent context’s table will always contain at least the same number of entries as the extended context. Therefore, the number of entries in the parent context will always be greater than or equal to the number of entries in any extended context’s table.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>Similar contextual information does not necessarily correspond to actual matching of the information fields. For example, two events are taking place at two locations with the same co-ordinates, but different place-names. In this case, the two location contexts can be considered as overlapping each other even though the place-names are different.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>SQLite does not support storing read timestamps like other RDBMS such as MySQL. In order to implement this functionality in SQLite, an explicit write operation to the table is necessary with every read operation. This locks the table during the write operation, and prevents concurrent read access, thereby affecting the performance of the query.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Creating such policies requires further extensive testing and is not within the scope of this research.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>Different context tables can have different values of <span class="math inline"><em>n</em></span>, as each context table stores different contextual information based on relevance and frequency of use. For example, location entries will be used differently than contacts, and therefore can have a different value of <span class="math inline"><em>n</em></span>.<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>In Android, objects instantiated by an app are created in the <em>heap</em>, a dynamic storage memory provided to the app.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>An Android Archive (extension .AAR) module is compiled from a Library project and is meant to be shared as a module between projects. It is a Zip archive containing a combination of compile code such as JAR and/or native .so files along with resources such as manifest, assets and other ancillary files.<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>Gradle is a project automation tool that provides dependency management features similar to Apache Ant and Apache Maven. Gradle is the default build system in Android studio, the official IDE for Android application development. More info at https://developer.android.com/tools/studio/index.html<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p>System classes are those classes that are available to all apps and processes and do not need to be included with the apps’ code. The app only needs to use the provided APIs to use the classes and their associated methods in its code.<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p>The meaning of a context is its intended contextual information. A <em>Location</em> context is used to store location information about a place. By changing its co-ordinates, the location and therefore the meaning of the context is being changed.<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p>Compared to tasks carried out in the background such as downloading a file, UI elements and the information they contain affect the user experience in a larger capacity since the user directly sees and interacts with them.<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27" role="doc-endnote"><p>Using Java’s Random class (http://docs.oracle.com/javase/7/docs/api/java/util/Random.html) that generates a stream of pseudo-random numbers using a 48-bit seed modified using a linear congruential formula.<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p>Nexus 7 Wi-Fi only, model year 2013, Qualcomm Snapdragon S4Pro, CPU Quad-core 1.5 GHz Krait, GPU Adreno 320, 2 GB RAM.<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p>Android Debug Bridge (adb) is a versatile command line tool that allows debugging a connected Android-powered device. Logcat provides a mechanism for collecting and viewing filtered logs from various applications and portions of the system through adb. More info about adb and logcat can be found at https://developer.android.com<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p>The IPC and marshaling is performed by the Android system. Its time in included as part of the Context Manager’s operations since it is part of the operation. The total time is useful to identify the performance of the Contextual Data Sharing Model from the user’s point of view.<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p>The time taken by the Context Manager is inclusive of the time required to create the <em>Event</em> objects since the user app will receive the database results as <em>Event</em> objects from the Context Manager.<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32" role="doc-endnote"><p>The sudden increase in the time values can be attributed to the allotment of heap space by the Android system. If the results of a query do not fit in the app’s available heap space, the system attempts to allot more heap space. This stalls the app process until the heap space is made available. Creating a large number of <em>Event</em> objects also fills up the heap space, and has a similar effect.<a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p>A ListView is a view group that displays a list of scrollable items that are automatically inserted using an Adapter object that pulls content from a source such as an array or database query. More info about ListViews can be found at https://developer.android.com<a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p>In Android, the IPC mechanism only copies the references to the data in memory between processes rather than the entire data. This saves the costs involved in copying all of the data and works within the sandboxing model.<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p>HomeKit (developed by Apple) is a framework in iOS 8 for communicating and controlling connected accessories in a user’s home and is integrated with Siri. The Nest Learning Thermostat (developed by Nest Labs, acquired by Google in 2014) is an electronic, programmable, and self-learning Wi-Fi-enabled thermostat available for Android and iOS, which can be controlled using the Google Now application.<a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
