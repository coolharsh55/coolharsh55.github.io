<!DOCTYPE html>
<html
    lang="en"
    prefix="schema: http://schema.org/ ">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>KWEST: A Semantically Tagged Virtual File System</title>
    <meta name="description" content=""/>
    <meta name="schema:name" content="KWEST: A Semantically Tagged Virtual File System">
    <meta name="schema:description" content="A virtual filesystem that allows automated semantic organisation and suggestions">
    <meta name="schema:datePublished" content="item.schema_datePublished">
    <meta name="schema:keywords" content="filesystem,recommender-system,semantics,">
    <meta name="schema:author" content="https://harshp.com/me">
    <meta name="schema:identifier" content="https://harshp.com/research/publications/001a-kwest-semantically-tagged-virtual-fs">
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@coolharsh55">
    <meta name="twitter:creator" content="@coolharsh55">
    <meta property="og:url" content="https://doi.org/10.5281/zenodo.4481916">
    <meta property="og:title" content="KWEST: A Semantically Tagged Virtual File System">
    <meta property="og:description" content="A virtual filesystem that allows automated semantic organisation and suggestions">
    <link rel="stylesheet" href="/css/sitebase.css" />
</head>
<body>
    <header><nav>
        <a href="/" property="schema:isPartOf" typeof="schema:Website">harshp.com</a> 
| <a href="/research">research</a> | <a href="/research/publications">publications</a>    </nav></header>
    <main>
    <article typeof="https://harshp.com/code/vocab#RenderedItem https://harshp.com/code/vocab#ShortPaper https://schema.org/ScholarlyArticle " resource="https://harshp.com/research/publications/001a-kwest-semantically-tagged-virtual-fs">
        <h1 property="schema:name schema:headline">KWEST: A Semantically Tagged Virtual File System</h1>
<div id="description">
	<small>
	<time datetime="2012-12-09T00:00:00">2012-12-09T00:00:00</time>
    <i>Short Paper</i>
    <br/>
    <span class='note'>accepted, unpublished</span>
    International Conference on Advanced Computer Engineering and Applications
    <br/>
    &#9997;<i>
    Aseem Gogte*    , Sahil Gupta*    , <u>Harshvardhan J. Pandit</u>*    , Rohit Sharma*    </i>
    <br/>
    <a href="https://doi.org/10.5281/zenodo.4481916">publication</a>
        &#x1f513;copies:
        <a href="https://harshp.com/research/publications/001a-kwest-semantically-tagged-virtual-fs">harshp.com</a>
        , <a href="https://doi.org/10.5281/zenodo.4481916">zenodo</a>
    <br/>
    A virtual filesystem that allows automated semantic organisation and suggestions
    </small>
</div>
        <div id="content" property="schema:articleBody">
        <h3>Abstract</h3>
<p>The limitation of data representation in today’s file systems is that data representation is bound only in a single way of hierarchically organizing files. A semantic file system provides addressing and querying based on the content rather than storage location. Semantic tagging is a new way to organize files by using tags in place of directories. In traditional file systems, symbolic links become non-existent when file paths are changed. Assigning multiple tags to each file ensures that the file is linked to several virtual directories based on its content. By providing semantic access to information, users can organize files in a more intuitive way. In this way, the same file can be accessed through more than one virtual directory. The metadata and linkages for tagging are stored in a relational database which is invisible to the user. This allows efficient searching based on context rather than keywords. The classification of files into various ontologies can be done by the user manually or through automated rules. For certain files types, tags can be suggested by analyzing the contents of files. The system would be modular in design to allow customization while retaining a flexible and stable structure.</p>
<p><em><strong>Keywords— semantics, indexing, classification, database, tagging, virtual file system, information access, metadata</strong></em></p>
<h2 id="introduction"> Introduction</h2>
<p>Traditional file systems are mono-hierarchical and implement directory trees to categorize and store files. In such systems, directories are the only means to access particular files.</p>
<p>The path of a file contains directories, which refer to its context and categorization. As an example <em>“c:\photos\college\trip\museum\*.jpg”</em> refers to all photos of a museum from a college trip. In this case, it is not possible to store that photo in another directory say <em>“c:\photos\museum\*.jpg”</em> without copying the file. This severely limits the searching capabilities in a file system.</p>
<p>The user is faced with the dilemma of which directory best represents the context of current file. While storing, the file is identified by its file name alone, which serves as its identifier. For searching a particular file, the user has to accurately remember the path and file name. A file cannot be searched by any other information relating to its context. Creating the directory structure is based on the users organizational skills. Searching or browsing through someone else’s data is tricky as the organization is different for every user.</p>
<p>Previous approaches [1] to such problems provided symbolic links and aliases as an incomplete answer. Symbolic links become redundant when the target file paths are changed. Similarly, aliases may become redundant or may not function properly with certain programs. Working with such solutions requires advanced skills on the user’s part. Keyword based searches which extract metadata from files were brought to fore by Apple’s Spotlight [3] and Google’s Desktop Search [2]. Both function only on limited file types and do not allow manual categorization.</p>
<p>This led to the development of semantic file systems, containing categorization of files based on context. It provides access to files by using categories formed from extracting metadata. It is similar to how music files can be searched by artist, genre, album etc. However, this presents a limitation on the amount and capabilities of what metadata can be extracted from a file. Virtual directories [11] are used to represent data from the file system. These directories do not have a permanent listing and the user has to explicitly query for data. There have been several implementations based on semantic file systems.</p>
<p>However, they have several limitations in usability. Most of the systems are based only on a few key points, such as limitations over file types.</p>
<p>Our aim thus is to create a semantic solution to the problems and shortcomings of traditional file systems while covering the limitations of other implemented systems.</p>
<h2 id="related-work">Related Work</h2>
<p>Over the years, organizing and retrieving information accurately and efficiently has attracted lot of attention. While few have been successful, a number of innovative implementations [1] have emerged. The idea of using a file’s semantics as the means to categorize it has been around for quite some time. This section discusses the various implementations made in the field of semantic file system. An efficient implementation of keyword based searching was brought to the desktop by Google’s Desktop Search [2] and Apple’s Spotlight [3]. Both allow efficient and quick file retrieval based on keywords. They support many file types and have a simple interface which attracts a large number of users. However, both of them are limited to returning search results without any way to organizing contents. In addition, they do not provide any provision to the user for classification of data. This limitation prevented the user from having a personalized way to retrieve data stored by them.</p>
<p>Semantic systems depend on data stored inside the files rather merely relying on an file’s attributes. Most implementations use common methodologies like content recognition [4], tagging [5], extracting metadata, etc. to categorize files by using various algorithms.</p>
<p>”Semantic File System” [6], as developed by O’Toole and Gittord in 1992, provides access to file contents and metadata by extracting the attributes using special modules called ”transducers”. It was one of the very first attempts to classify files by semantics using metadata. Its biggest drawback was the need for file type specific transducers which were necessary to extract meta information and content from the file. Also, the user does not have any say in what kind of category the file is classified under. This drawback makes it an unattractive option to the general user. It was decided during designing Kwest, that it is necessary to involve the end-user in the tagging process. This allows each user to have their own personal way of classification and organization of files.</p>
<p>NHFS (Non Hierarchical File System) [7] was a system developed by Robert Freund in July 2007. It allows the user to place any file into any number of directories. Likewise, any directory can be placed into as many directories as required. NHFS therefore allows one to create a non-hierarchical structure with poly-hierarchically connected files. This allows for a powerful metaphor of finding a file in any of the category (directory) it could be stored under. Therefore, we decided to retain this feature by using tags in place of actual directories. Tags are associated with files and other tags as well. Thus, a tag may be placed under multiple tags allowing a relationship to be defined between them. This analogy is much more powerful than restricting files to actual directories. Using tags prevents duplication and redundancy, making it an efficient implementation.</p>
<p>A more recent implementation is Tagsistant [8], which is a semantic file system that also attempts to organize files using tags. It interacts with the Linux kernel using the FUSE module. Under Tagsistant, directories are considered to be equivalent to tags. As a consequence, creating a directory is creating a tag and putting a file inside a directory means tagging that file. After you have tagged your files, you can search all of them by using queries. Queries are just paths where each element is either a directory or logical operators. The entire system has a modular design and uses SQLite. However, it suffers from some speed issues and the lack of SQL indexes. Major flaws of this design were high consumption of inodes on real file systems and high computational time which was required to fulfill each request. Most of the features of Tagsistant were decided to be included in Kwest. These were modular design, SQLite repository, tagged structure, etc. which enhance the semantics of a file system. However, care must be taken to prevent the occurrence of similar drawbacks.</p>
<p>Another implementation called Tagster [9], is a peer-to-peer tagging application for organizing desktop data. It is platform independent and is implemented in JAVA. Multiple files and also directories can be tagged through its interface. The selected directories are recursively examined and all files contained within them are tagged. The GUI for a Linux system consists of three main areas. Namely - ”Tag view”: which displays a list of tags, ”Resource view”: which lists resources that have the currently selected tags assigned and ”User view”: that displays a list of users that have tagged the currently selected resource with some selected tag. It also includes GUI support for Windows with some unresolved issues. However, it lacks auto classification of data due to which several common tags may be generated for each user increasing the database size.</p>
<h2 id="proposed-system">Proposed System</h2>
<p>Kwest is a virtual file system that is designed to help users organize information using the familiar hierarchical file/directory structure. It aims at providing a feasible solution towards efficient contextual storage and searching of information. It implements a semantic file system which structures data according to their context and intent. This allows the data to be addressed by their content and makes relevance in searching an efficient operation.</p>
<p>The system extracts metadata into tags and stores it in a relational database. These tags can be file attributes such as size, type, name etc. as well as extracted metadata such as author, content title, etc. Categorizing files by metadata allows linking a file in multiple ways while being able to search it using its context. This enables the users to find relevant information in as few searches as possible.</p>
<p>Assigning tags can be managed by automated rules and manual inputs. This makes the semantics mold according to the user’s perspectives and helps make information relevant to the person managing it. The modular architecture of the system allows for plugins which can extend the functionality. For example a plugin to add more detection capabilities for certain file types will enhance the metadata extraction on those files. This makes the system highly customizable to power users. The automated rules help automate tasks and data categorization based on user inputs.</p>
<p>Virtual directories are used to display stored files in a semantic organization. Search results are displayed through dynamically created listings, which correspond to semantic segregation. The entire implementation is based on a virtual file system which manages only the data organization. The underlying file system takes care of storage. This allows it to be ported in future to any file system.</p>
<p>Finally, the system is implemented using open source technologies, which greatly reduce the cost and compromises associated with paid software. Thus the system aims to address the current shortcomings of relevant information access and storage by creating a virtual semantic file system which manages the data and provides search information based on semantics. The major design features are described in this section.</p>
<h3 id="tags">Tags</h3>
<h4 id="manual-tagging">Manual Tagging:</h4>
<p>Manual tagging is the basis of semantics in Kwest. The user can assign any tag to the files in Kwest. These tags are then stored internally in a database. The user can create new tags or use tags already defined by the system. Total freedom is given to the user to organize data.</p>
<h4 id="automatic-tagging">Automatic Tagging</h4>
<p>Kwest also features automatic tagging of files. The user can define certain rules under which files will be assigned tags. The system will implement those rules for all files satisfying the defined constraints. This would prevent repetitive tagging operations for the user.</p>
<h4 id="importing-tags">Importing tags</h4>
<p>Certain popular file formats such as mp3, jpeg etc. have metadata embedded in them. Kwest supports such popular format and uses this metadata to automatically assign tags to the files. This feature enables the user to collectively classify and store the data under these tags.</p>
<h3 id="database"> Database</h3>
<h4 id="consistency">Consistency</h4>
<p>Kwest uses an internal database to store and manage data. It is vital that the database always remains consistent. Kwest uses logging mechanisms to ensure that operations on the database always reach an endpoint.</p>
<h4 id="access">Access</h4>
<p>The database is included in the same directory as the Kwest executable. The files are not locked down or are access restricted. Other applications, modules or tools can access the database. However, this feature is made available with the understanding that the integrity of the database will be maintained always.</p>
<h3 id="relation-with-existing-data">Relation with existing data</h3>
<h4 id="importing-semantics">Importing semantics</h4>
<p>Users already have certain organizational structures in the way they store data in file systems. Kwest imports these semantics by converting the storage hierarchy to tag-based hierarchy. This allows the entire file system to be imported into Kwest along with the users’ previous organization structure.</p>
<h4 id="reflecting-changes-to-filesystem">Reflecting changes to filesystem</h4>
<p>When users carry out certain changes in Kwest such as copying files, deleting files etc., these changes are virtual and do not affect actual file systems. However, Kwest can enforce these operations on the real files in certain cases.</p>
<h3 id="exporting-semantics">Exporting semantics</h3>
<h4 id="export-filesystem">Export filesystem</h4>
<p>As the entire file system exists as a virtual entity, Kwest provides the export feature. Where the file system can be exported to another system where the data can be imported by another instance of Kwest.</p>
<h4 id="export-tagged-files">Export tagged files</h4>
<p>It is also possible for the user to export data under certain tags to an external location. The semantic organization showed by tags is converted to actual directories and files are then copied to these directories. This way the user can export Kwest semantics and data to outside locations.</p>
<h3 id="modularity">Modularity</h3>
<h4 id="modules-as-plugins">Modules as plugins</h4>
<p>Kwest is an extendible system. It can use external modules to increase functionality or to modify existing operations. Support for using modules is built into Kwest right from the design stage.</p>
<h4 id="support-for-developers">Support for developers</h4>
<p>Kwest provides support to developers by providing access to all internal features and database. The API layer allows developers to easily supplement internal operations with their modules.</p>
<h2 id="system-design">System Design</h2>
<p>Kwest is implemented using loadable kernel module known as FUSE. User may interact with kwest like any other file system via Command line or file managers like Nautilus. Data is passed on to FUSE through the virtual file system. FUSE implements the operations of file system. FUSE uses Glibc and Libfuse for performing its operations. Glibc is the <a href="http://en.wikipedia.org/wiki/GNU_Project">GNU Project</a>'s implementation of the <a href="http://en.wikipedia.org/wiki/C_standard_library">C standard library</a>. It provides functions for tasks like I/O processing, mathematical computation, memory allocation, etc. Libfuse contains functions internally used by fuse to create and manage virtual file system. SQLite will be used for storing all data relevant with the file system. To extract metadata, Kwest makes use of external libraries such as Taglib, EXIF.</p>
<figure>
    <img src="img/001a-kwest.png" />
    <figcaption>Figure 1: Design of Kewst</figcaption>
</figure>
<h2 id="mathematical-model">Mathematical Model</h2>
<p>The relationship between files and tags can be represented by using Set theory. Set theory is the branch of mathematics that studies sets, which are collections of objects. The following mathematical model represents the working of this file system.</p>
<p>The following dynamic and variable sets are defined as,</p>
<p>F: Set of Files</p>
<p>T: Set of Tags</p>
<p>S: Set of Tags in query (S<em>⊆</em> T)</p>
<h3 id="relation-between-files-f-and-tags-t">Relation between Files (F) and Tags (T)</h3>
<p>R = { (f, t ) | f has tag t; f <em>∈</em> F, t<em>∈</em> T }</p>
<p>Here R defines the relation between a file f and its tag t where R <em>⊆</em> F × T. This relationship is many-to-many. That is a file can have many tags, and a tag can describe many files.</p>
<h3 id="operations">Operations</h3>
<p>g(f) = { t : f R t }</p>
<p>g is an operation which takes input as files f and returns the set of tags (t<em>∈</em> S) related by R to that file.</p>
<p>h(t) = { f : f R t }</p>
<p>h is an operation which takes input as tags t and returns the set of files (f <em>∈</em> F<sub>S</sub>) related by R to that tag.</p>
<h3 id="storing-tags-and-files">Storing Tags and Files</h3>
<p>The relation R is stored as a set of ordered pairs (f, t), where R <em>⊆</em> F × T. The operations g and h operate on these ordered pairs and return mapped or matched elements. A relation which has to be added must be represented in the form of ordered pair (f, t). Storage of all relations is given by F × T where ordered pairs exist according to</p>
<p>R = {f <em>∈</em> F, t <em>∈</em> T | f R t}.</p>
<p>For example, we have the sets and their relations as:</p>
<p>F = {f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>}, T = {t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>},</p>
<p>R = {f<sub>1</sub> R t<sub>1</sub>, f<sub>2</sub> R t<sub>2</sub>, f<sub>3</sub> R t<sub>1</sub>, f<sub>1</sub> R t<sub>3</sub>}</p>
<p>Then we store this relation by its ordered pairs given by:</p>
<p>R = {(f<sub>1</sub>, t<sub>1</sub>), (f<sub>2</sub>, t<sub>2</sub>), (f<sub>3</sub>, t<sub>1</sub>), (f<sub>1</sub>, t<sub>3</sub>)}</p>
<h3 id="queries">Queries</h3>
<p>A query operation on a single tag is expressed as:</p>
<p>q (t) = F<sub>S</sub> where { f <em>∈</em> F<sub>S</sub> | h(t) = f }</p>
<p>The general form of a query is a string which contains tags and operators. For example, we have two tags (t<sub>1</sub>, t<sub>2</sub>) and operator σ. The query Q can be defined in terms of q as:</p>
<p>Q (t<sub>1</sub>, σ, t<sub>2</sub>) = q (t<sub>1</sub>) σ q (t<sub>2</sub>)</p>
<p>The operation σ can be any one of Union ∪, Intersection ∩, Symmetric difference Ɵ etc. If no operation is explicitly mentioned, by default Intersection ∩ is performed.</p>
<h2 id="conclusion-and-future-work">Conclusion And Future Work </h2>
<p>In this paper we have proposed a system for organizing files using meta information by exploiting semantic information to provide efficient and scalable architecture. The system handles complex queries while enhancing functionality. Its novelty lies in the way it associates tags and derives rules that enables traversal based on semantics rather than path.</p>
<p>Currently, Kwest is in its initial stage of development. Its features are limited but its modular architecture allows plugins to be added which can add additional functionality, and recognition for more file types. This allows the system to be extended and modified according to the functionality required. The current implementation is based on the Linux kernel. Future implementations can be extended to other platforms and devices. As the system is a virtual entity, it does not need extensive modifications to be ported to other file systems and operating systems.</p>
<h5 id="references">References</h5>
<ol type="1">
<li><p>Mangold. C, A survey and classification of semantic search approaches, <em>Int. J. Metadata, Semantics and Ontology</em>, Vol. 2, No. 1, 2007, Page(s): 23-34.</p></li>
<li><p>Google Desktop Search, http://googledesktop.blogspot.in</p></li>
<li><p>Apple Spotlight, http://developer.apple.com/macosx/spotlight.html</p></li>
<li><p>Gopal. S, Yang. Y, Salomatin. K, Carbonell. J, Statistical Learning for File-Type Identification, <em>2011 10th International Conference on Machine Learning and Applications</em>, Page(s): 68-73.</p></li>
<li><p>Bloehdorn. S, Grlitz. O, Schenk. S, Vlkel. M, TagFS - Tag Semantics for Hierarchical File Systems, <em>In Proceedings of the 6th International Conference on Knowledge Management (I-KNOW 06),</em> Graz, Austria, September 6-8, 2006.</p></li>
<li><p>Gifford. D, Jouvelot. P, Sheldon. M, OToole. J, Sematic File Systems, 13th ACM Symposium on Operating Systems Principles, <em>ACM Operating Systems Review</em>, Oct. 1991, Page(s): 16-25.</p></li>
<li><p>Freund. R, File Systems and Usability the Missing Link, <em>Cognitive Science, University of Osnabruck July 2007</em>.</p></li>
<li><p>Tagsistant, http://www.tagsistant.net</p></li>
<li><p>Tagster, http://www.uni-koblenz.de</p></li>
<li><p>Chang. K, Perdana. I, Jain. M, Kartasasmita. I, Ramadhana. B, Sethuraman. K, Le. T, Chachra. N, Tikale. S, Knowledge File System - A principled approach to personal information management, <em>2010 IEEE International Conference on Data Mining Workshops</em>, Page(s): 1037-1044.</p></li>
<li><p>Mohan. P, Venkateswaran. S, Raghuraman, Dr. Siromoney. A, Semantic File Retrieval in File Systems using Virtual Directories. <em>Proc. Linux Expo Conference, Raleigh, NC</em>, May 2007, Page(s): 141-151.</p></li>
<li><p>Hua. Y, Jiang. H, Zhu. Y, Feng. D, Tian. L, Semantic-Aware Metadata Organization Paradigm in Next-Generation File Systems<em>, IEEE Transactions on Parallel And Distributed Systems,</em> Vol. 23, No. 2, February 2012, Page(s): 337-344.</p></li>
<li><p>Schroder. A, Fritzsche. R, Schmidt. S, Mitschick. A, Meiner. K, A Semantic Extension of a Hierarchical Storage Management System for Small and Medium-sized Enterprises, <em>Proceedings of the 1st International Workshop on Semantic Digital Archives (SDA 2011).</em></p></li>
<li><p>Eck. 0, Schaefer. D, A semantic file system for integrated product data management, <em>2011 Advanced Engineering Informatics,</em> Page(s): 177-184.</p></li>
<li><p>File system in USERspace (FUSE) homepage and documentation, http://fuse.sourceforge.net</p></li>
<li><p>SQLite database http://www.sqlite.org</p></li>
</ol>

        </div>
    </article>
    </main>
    <footer>
        <a href="/me">About Me</a> | <a href="/contact">Contact</a> | <a rel="me" href="https://eupolicy.social/@harsh">Mastodon</a> | privacy policy n/a | license: <a class="no-reformat" rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC bY-NC 4.0</a><br/>
        Made using <a href="https://www.w3.org/TR/rdf11-concepts/">RDF</a>, <a href="https://www.w3.org/TR/sparql11-query/">SPARQL</a>, and <a href="https://www.python.org/">Python</a> - <a href="https://github.com/coolharsh55/harshp.com/">source on GitHub</a>
    </footer>
    <script src="/js/utils.js"></script>
</body>
</html>